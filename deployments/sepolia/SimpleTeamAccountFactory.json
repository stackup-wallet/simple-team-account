{
  "address": "0x080ACC9E07deb1E9Ef351281a01079b0f717BCBF",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IEntryPoint",
          "name": "_entryPoint",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "accountImplementation",
      "outputs": [
        {
          "internalType": "contract SimpleTeamAccount",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "pubKeySlt1",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "pubKeySlt2",
              "type": "bytes32"
            },
            {
              "internalType": "enum Access",
              "name": "level",
              "type": "uint8"
            }
          ],
          "internalType": "struct Signer",
          "name": "signer",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "verifier",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "salt",
          "type": "uint256"
        }
      ],
      "name": "createAccount",
      "outputs": [
        {
          "internalType": "contract SimpleTeamAccount",
          "name": "ret",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "pubKeySlt1",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "pubKeySlt2",
              "type": "bytes32"
            },
            {
              "internalType": "enum Access",
              "name": "level",
              "type": "uint8"
            }
          ],
          "internalType": "struct Signer",
          "name": "signer",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "verifier",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "salt",
          "type": "uint256"
        }
      ],
      "name": "getAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xfe7de3b5b33991169372019a1a143cadc0fe333e9621bf786269eaaeeeaf8a01",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xf6731De143cd04d7e9aEBe3B1b00aDBBd4710249",
    "contractAddress": null,
    "transactionIndex": 155,
    "gasUsed": "2411116",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000004000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000800000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xe04b62e3651dc817bcf3adfaedf4ad93ac0a6125a5b0bc5571ba941fe0b88b88",
    "transactionHash": "0xfe7de3b5b33991169372019a1a143cadc0fe333e9621bf786269eaaeeeaf8a01",
    "logs": [
      {
        "transactionIndex": 155,
        "blockNumber": 7592938,
        "transactionHash": "0xfe7de3b5b33991169372019a1a143cadc0fe333e9621bf786269eaaeeeaf8a01",
        "address": "0x83e759DF2550d0cB1714F095D208aD7225FDa56a",
        "topics": [
          "0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2"
        ],
        "data": "0x000000000000000000000000000000000000000000000000ffffffffffffffff",
        "logIndex": 95,
        "blockHash": "0xe04b62e3651dc817bcf3adfaedf4ad93ac0a6125a5b0bc5571ba941fe0b88b88"
      }
    ],
    "blockNumber": 7592938,
    "cumulativeGasUsed": "10287947",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x0000000071727De22E5E9d8BAf0edAc6f37da032"
  ],
  "numDeployments": 1,
  "solcInputHash": "9a89a141ba9db785d46a480d4e61100b",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IEntryPoint\",\"name\":\"_entryPoint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"accountImplementation\",\"outputs\":[{\"internalType\":\"contract SimpleTeamAccount\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"pubKeySlt1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"pubKeySlt2\",\"type\":\"bytes32\"},{\"internalType\":\"enum Access\",\"name\":\"level\",\"type\":\"uint8\"}],\"internalType\":\"struct Signer\",\"name\":\"signer\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"createAccount\",\"outputs\":[{\"internalType\":\"contract SimpleTeamAccount\",\"name\":\"ret\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"pubKeySlt1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"pubKeySlt2\",\"type\":\"bytes32\"},{\"internalType\":\"enum Access\",\"name\":\"level\",\"type\":\"uint8\"}],\"internalType\":\"struct Signer\",\"name\":\"signer\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"createAccount((bytes32,bytes32,uint8),address,uint256)\":{\"notice\":\"create an account, and return its address. returns the address even if the account is already deployed. Note that during UserOperation execution, this method is called only if the account is not deployed. This method returns an existing account address so that entryPoint.getSenderAddress() would work even after account creation\"},\"getAddress((bytes32,bytes32,uint8),address,uint256)\":{\"notice\":\"calculate the counterfactual address of this account as it would be returned by createAccount()\"}},\"notice\":\"The factory contract for SimpleTeamAccount. SimpleTeamAccountFactory is originally forked from SimpleAccountFactory.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/samples/SimpleTeamAccountFactory.sol\":\"SimpleTeamAccountFactory\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Proxy} from \\\"../Proxy.sol\\\";\\nimport {ERC1967Utils} from \\\"./ERC1967Utils.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an\\n     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - If `data` is empty, `msg.value` must be zero.\\n     */\\n    constructor(address implementation, bytes memory _data) payable {\\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return ERC1967Utils.getImplementation();\\n    }\\n}\\n\",\"keccak256\":\"0xbfb6695731de677140fbf76c772ab08c4233a122fb51ac28ac120fc49bbbc4ec\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IBeacon} from \\\"../beacon/IBeacon.sol\\\";\\nimport {Address} from \\\"../../utils/Address.sol\\\";\\nimport {StorageSlot} from \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n */\\nlibrary ERC1967Utils {\\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev The `implementation` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev The `admin` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidAdmin(address admin);\\n\\n    /**\\n     * @dev The `beacon` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidBeacon(address beacon);\\n\\n    /**\\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\\n     */\\n    error ERC1967NonPayable();\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (newImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(newImplementation);\\n        }\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967InvalidAdmin(address(0));\\n        }\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {IERC1967-AdminChanged} event.\\n     */\\n    function changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.beacon\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (newBeacon.code.length == 0) {\\n            revert ERC1967InvalidBeacon(newBeacon);\\n        }\\n\\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\\n\\n        address beaconImplementation = IBeacon(newBeacon).implementation();\\n        if (beaconImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(beaconImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-BeaconUpgraded} event.\\n     *\\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\\n     * efficiency.\\n     */\\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\\n     * if an upgrade doesn't perform an initialization call.\\n     */\\n    function _checkNonPayable() private {\\n        if (msg.value > 0) {\\n            revert ERC1967NonPayable();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x06a78f9b3ee3e6d0eb4e4cd635ba49960bea34cac1db8c0a27c75f2319f1fd65\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\\n     * function and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n}\\n\",\"keccak256\":\"0xc3f2ec76a3de8ed7a7007c46166f5550c72c7709e3fc7e8bb3111a7191cdedbd\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {UpgradeableBeacon} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xc59a78b07b44b2cf2e8ab4175fca91e8eca1eee2df7357b8d2a8833e5ea1f64c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface that must be implemented by smart contracts in order to receive\\n * ERC-1155 token transfers.\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xb69597a63b202e28401128bed6a6d259e8730191274471af7303eafb247881a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x7f7a26306c79a65fb8b3b6c757cd74660c532cd8a02e165488e30027dd34ca49\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaf28a975a78550e45f65e559a3ad6a5ad43b9b8a37366999abd1b7084eb70721\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Not enough balance for performing a CREATE2 deploy.\\n     */\\n    error Create2InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev There's no code to deploy.\\n     */\\n    error Create2EmptyBytecode();\\n\\n    /**\\n     * @dev The deployment failed.\\n     */\\n    error Create2FailedDeployment();\\n\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\\n        if (address(this).balance < amount) {\\n            revert Create2InsufficientBalance(address(this).balance, amount);\\n        }\\n        if (bytecode.length == 0) {\\n            revert Create2EmptyBytecode();\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        if (addr == address(0)) {\\n            revert Create2FailedDeployment();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \\u2193 ptr ...  \\u2193 ptr + 0x0B (start) ...  \\u2193 ptr + 0x20 ...  \\u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2b9807d194b92f1068d868e9587d27037264a9a067c778486f86ae21c61cbd5e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x32ba59b4b7299237c8ba56319110989d7978a039faf754793064e967e5894418\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"contracts/core/BaseAccount.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-empty-blocks */\\n\\nimport \\\"../interfaces/IAccount.sol\\\";\\nimport \\\"../interfaces/IEntryPoint.sol\\\";\\nimport \\\"./UserOperationLib.sol\\\";\\n\\n/**\\n * Basic account implementation.\\n * This contract provides the basic logic for implementing the IAccount interface - validateUserOp\\n * Specific account implementation should inherit it and provide the account-specific logic.\\n */\\nabstract contract BaseAccount is IAccount {\\n    using UserOperationLib for PackedUserOperation;\\n\\n    /**\\n     * Return the account nonce.\\n     * This method returns the next sequential nonce.\\n     * For a nonce of a specific key, use `entrypoint.getNonce(account, key)`\\n     */\\n    function getNonce() public view virtual returns (uint256) {\\n        return entryPoint().getNonce(address(this), 0);\\n    }\\n\\n    /**\\n     * Return the entryPoint used by this account.\\n     * Subclass should return the current entryPoint used by this account.\\n     */\\n    function entryPoint() public view virtual returns (IEntryPoint);\\n\\n    /// @inheritdoc IAccount\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    ) external virtual override returns (uint256 validationData) {\\n        _requireFromEntryPoint();\\n        validationData = _validateSignature(userOp, userOpHash);\\n        _validateNonce(userOp.nonce);\\n        _payPrefund(missingAccountFunds);\\n    }\\n\\n    /**\\n     * Ensure the request comes from the known entrypoint.\\n     */\\n    function _requireFromEntryPoint() internal view virtual {\\n        require(\\n            msg.sender == address(entryPoint()),\\n            \\\"account: not from EntryPoint\\\"\\n        );\\n    }\\n\\n    /**\\n     * Validate the signature is valid for this message.\\n     * @param userOp          - Validate the userOp.signature field.\\n     * @param userOpHash      - Convenient field: the hash of the request, to check the signature against.\\n     *                          (also hashes the entrypoint and chain id)\\n     * @return validationData - Signature and time-range of this operation.\\n     *                          <20-byte> aggregatorOrSigFail - 0 for valid signature, 1 to mark signature failure,\\n     *                                    otherwise, an address of an aggregator contract.\\n     *                          <6-byte> validUntil - last timestamp this operation is valid. 0 for \\\"indefinite\\\"\\n     *                          <6-byte> validAfter - first timestamp this operation is valid\\n     *                          If the account doesn't use time-range, it is enough to return\\n     *                          SIG_VALIDATION_FAILED value (1) for signature failure.\\n     *                          Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function _validateSignature(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    ) internal virtual returns (uint256 validationData);\\n\\n    /**\\n     * Validate the nonce of the UserOperation.\\n     * This method may validate the nonce requirement of this account.\\n     * e.g.\\n     * To limit the nonce to use sequenced UserOps only (no \\\"out of order\\\" UserOps):\\n     *      `require(nonce < type(uint64).max)`\\n     * For a hypothetical account that *requires* the nonce to be out-of-order:\\n     *      `require(nonce & type(uint64).max == 0)`\\n     *\\n     * The actual nonce uniqueness is managed by the EntryPoint, and thus no other\\n     * action is needed by the account itself.\\n     *\\n     * @param nonce to validate\\n     *\\n     * solhint-disable-next-line no-empty-blocks\\n     */\\n    function _validateNonce(uint256 nonce) internal view virtual {\\n    }\\n\\n    /**\\n     * Sends to the entrypoint (msg.sender) the missing funds for this transaction.\\n     * SubClass MAY override this method for better funds management\\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\\n     * it will not be required to send again).\\n     * @param missingAccountFunds - The minimum value this method should send the entrypoint.\\n     *                              This value MAY be zero, in case there is enough deposit,\\n     *                              or the userOp has a paymaster.\\n     */\\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\\n        if (missingAccountFunds != 0) {\\n            (bool success, ) = payable(msg.sender).call{\\n                value: missingAccountFunds,\\n                gas: type(uint256).max\\n            }(\\\"\\\");\\n            (success);\\n            //ignore failure (its EntryPoint's job to verify, not account.)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2736272f077d1699b8b8bf8be18d1c20e506668fc52b3293da70d17e63794358\",\"license\":\"GPL-3.0\"},\"contracts/core/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n\\n /*\\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\\n  * must return this value in case of signature failure, instead of revert.\\n  */\\nuint256 constant SIG_VALIDATION_FAILED = 1;\\n\\n\\n/*\\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\\n * return this value on success.\\n */\\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\\n\\n\\n/**\\n * Returned data from validateUserOp.\\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\\n * parsed by `_parseValidationData`.\\n * @param aggregator  - address(0) - The account validated the signature by itself.\\n *                      address(1) - The account failed to validate the signature.\\n *                      otherwise - This is an address of a signature aggregator that must\\n *                                  be used to validate the signature.\\n * @param validAfter  - This UserOp is valid only after this timestamp.\\n * @param validaUntil - This UserOp is valid only up to this timestamp.\\n */\\nstruct ValidationData {\\n    address aggregator;\\n    uint48 validAfter;\\n    uint48 validUntil;\\n}\\n\\n/**\\n * Extract sigFailed, validAfter, validUntil.\\n * Also convert zero validUntil to type(uint48).max.\\n * @param validationData - The packed validation data.\\n */\\nfunction _parseValidationData(\\n    uint256 validationData\\n) pure returns (ValidationData memory data) {\\n    address aggregator = address(uint160(validationData));\\n    uint48 validUntil = uint48(validationData >> 160);\\n    if (validUntil == 0) {\\n        validUntil = type(uint48).max;\\n    }\\n    uint48 validAfter = uint48(validationData >> (48 + 160));\\n    return ValidationData(aggregator, validAfter, validUntil);\\n}\\n\\n/**\\n * Helper to pack the return value for validateUserOp.\\n * @param data - The ValidationData to pack.\\n */\\nfunction _packValidationData(\\n    ValidationData memory data\\n) pure returns (uint256) {\\n    return\\n        uint160(data.aggregator) |\\n        (uint256(data.validUntil) << 160) |\\n        (uint256(data.validAfter) << (160 + 48));\\n}\\n\\n/**\\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\\n * @param sigFailed  - True for signature failure, false for success.\\n * @param validUntil - Last timestamp this UserOperation is valid (or zero for infinite).\\n * @param validAfter - First timestamp this UserOperation is valid.\\n */\\nfunction _packValidationData(\\n    bool sigFailed,\\n    uint48 validUntil,\\n    uint48 validAfter\\n) pure returns (uint256) {\\n    return\\n        (sigFailed ? 1 : 0) |\\n        (uint256(validUntil) << 160) |\\n        (uint256(validAfter) << (160 + 48));\\n}\\n\\n/**\\n * keccak function over calldata.\\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\\n */\\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\\n        assembly (\\\"memory-safe\\\") {\\n            let mem := mload(0x40)\\n            let len := data.length\\n            calldatacopy(mem, data.offset, len)\\n            ret := keccak256(mem, len)\\n        }\\n    }\\n\\n\\n/**\\n * The minimum of two numbers.\\n * @param a - First number.\\n * @param b - Second number.\\n */\\n    function min(uint256 a, uint256 b) pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\",\"keccak256\":\"0x6247e011a6cb0b263b3aa098822977181674d91b62e5bdfe04c6e66f72da25d6\",\"license\":\"GPL-3.0\"},\"contracts/core/UserOperationLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-inline-assembly */\\n\\nimport \\\"../interfaces/PackedUserOperation.sol\\\";\\nimport {calldataKeccak, min} from \\\"./Helpers.sol\\\";\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n\\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\\n    /**\\n     * Get sender from user operation data.\\n     * @param userOp - The user operation data.\\n     */\\n    function getSender(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {\\n            data := calldataload(userOp)\\n        }\\n        return address(uint160(data));\\n    }\\n\\n    /**\\n     * Relayer/block builder might submit the TX with higher priorityFee,\\n     * but the user should not pay above what he signed for.\\n     * @param userOp - The user operation data.\\n     */\\n    function gasPrice(\\n        PackedUserOperation calldata userOp\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\\n            if (maxFeePerGas == maxPriorityFeePerGas) {\\n                //legacy mode (for networks that don't support basefee opcode)\\n                return maxFeePerGas;\\n            }\\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n        }\\n    }\\n\\n    /**\\n     * Pack the user operation data into bytes for hashing.\\n     * @param userOp - The user operation data.\\n     */\\n    function encode(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (bytes memory ret) {\\n        address sender = getSender(userOp);\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        bytes32 accountGasLimits = userOp.accountGasLimits;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        bytes32 gasFees = userOp.gasFees;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return abi.encode(\\n            sender, nonce,\\n            hashInitCode, hashCallData,\\n            accountGasLimits, preVerificationGas, gasFees,\\n            hashPaymasterAndData\\n        );\\n    }\\n\\n    function unpackUints(\\n        bytes32 packed\\n    ) internal pure returns (uint256 high128, uint256 low128) {\\n        return (uint128(bytes16(packed)), uint128(uint256(packed)));\\n    }\\n\\n    //unpack just the high 128-bits from a packed value\\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\\n        return uint256(packed) >> 128;\\n    }\\n\\n    // unpack just the low 128-bits from a packed value\\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\\n        return uint128(uint256(packed));\\n    }\\n\\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackHigh128(userOp.gasFees);\\n    }\\n\\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackLow128(userOp.gasFees);\\n    }\\n\\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackHigh128(userOp.accountGasLimits);\\n    }\\n\\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackLow128(userOp.accountGasLimits);\\n    }\\n\\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\\n    }\\n\\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\\n    }\\n\\n    function unpackPaymasterStaticFields(\\n        bytes calldata paymasterAndData\\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\\n        return (\\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\\n        );\\n    }\\n\\n    /**\\n     * Hash the user operation data.\\n     * @param userOp - The user operation data.\\n     */\\n    function hash(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (bytes32) {\\n        return keccak256(encode(userOp));\\n    }\\n}\\n\",\"keccak256\":\"0x9d50ece985d35f82e33e5da417595c86fac10449e3d10895d08363d33aad454b\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IAccount.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\nimport \\\"./PackedUserOperation.sol\\\";\\n\\ninterface IAccount {\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\\n     * This allows making a \\\"simulation call\\\" without a valid signature\\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp              - The operation that is about to be executed.\\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\\n     *                              for future calls. Can be withdrawn anytime using \\\"entryPoint.withdrawTo()\\\".\\n     *                              In case there is a paymaster in the request (or the current deposit is high\\n     *                              enough), this value will be zero.\\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\\n     *                              `_unpackValidationData` to encode and decode.\\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\\n     *                                 otherwise, an address of an \\\"authorizer\\\" contract.\\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0 for \\\"indefinite\\\"\\n     *                              <6-byte> validAfter - First timestamp this operation is valid\\n     *                                                    If an account doesn't use time-range, it is enough to\\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    ) external returns (uint256 validationData);\\n}\\n\",\"keccak256\":\"0x38710bec0cb20ff4ceef46a80475b5bdabc27b7efd2687fd473db68332f61b78\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\nimport \\\"./PackedUserOperation.sol\\\";\\n\\n/**\\n * Aggregated Signatures validator.\\n */\\ninterface IAggregator {\\n    /**\\n     * Validate aggregated signature.\\n     * Revert if the aggregated signature does not match the given list of operations.\\n     * @param userOps   - Array of UserOperations to validate the signature for.\\n     * @param signature - The aggregated signature.\\n     */\\n    function validateSignatures(\\n        PackedUserOperation[] calldata userOps,\\n        bytes calldata signature\\n    ) external view;\\n\\n    /**\\n     * Validate signature of a single userOp.\\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\\n     * the aggregator this account uses.\\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\\n     * @param userOp        - The userOperation received from the user.\\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\\n     *                        (usually empty, unless account and aggregator support some kind of \\\"multisig\\\".\\n     */\\n    function validateUserOpSignature(\\n        PackedUserOperation calldata userOp\\n    ) external view returns (bytes memory sigForUserOp);\\n\\n    /**\\n     * Aggregate multiple signatures into a single value.\\n     * This method is called off-chain to calculate the signature to pass with handleOps()\\n     * bundler MAY use optimized custom code perform this aggregation.\\n     * @param userOps              - Array of UserOperations to collect the signatures from.\\n     * @return aggregatedSignature - The aggregated signature.\\n     */\\n    function aggregateSignatures(\\n        PackedUserOperation[] calldata userOps\\n    ) external view returns (bytes memory aggregatedSignature);\\n}\\n\",\"keccak256\":\"0xf100d6fcc0c3b450b13e979b6a42c628c292a1bc340eccc2e7796b80e3975588\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IEntryPoint.sol\":{\"content\":\"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./PackedUserOperation.sol\\\";\\nimport \\\"./IStakeManager.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\nimport \\\"./INonceManager.sol\\\";\\n\\ninterface IEntryPoint is IStakeManager, INonceManager {\\n    /***\\n     * An event emitted after each successful request.\\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\\n     * @param sender        - The account that generates this request.\\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\\n     * @param nonce         - The nonce value from the request.\\n     * @param success       - True if the sender transaction succeeded, false if reverted.\\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\\n     *                        validation and execution).\\n     */\\n    event UserOperationEvent(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address indexed paymaster,\\n        uint256 nonce,\\n        bool success,\\n        uint256 actualGasCost,\\n        uint256 actualGasUsed\\n    );\\n\\n    /**\\n     * Account \\\"sender\\\" was deployed.\\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\\n     * @param sender     - The account that is deployed\\n     * @param factory    - The factory used to deploy this account (in the initCode)\\n     * @param paymaster  - The paymaster used by this UserOp\\n     */\\n    event AccountDeployed(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address factory,\\n        address paymaster\\n    );\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length.\\n     * @param userOpHash   - The request unique identifier.\\n     * @param sender       - The sender of this request.\\n     * @param nonce        - The nonce used in the request.\\n     * @param revertReason - The return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event UserOperationRevertReason(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce,\\n        bytes revertReason\\n    );\\n\\n    /**\\n     * An event emitted if the UserOperation Paymaster's \\\"postOp\\\" call reverted with non-zero length.\\n     * @param userOpHash   - The request unique identifier.\\n     * @param sender       - The sender of this request.\\n     * @param nonce        - The nonce used in the request.\\n     * @param revertReason - The return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event PostOpRevertReason(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce,\\n        bytes revertReason\\n    );\\n\\n    /**\\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\\n     * @param userOpHash   - The request unique identifier.\\n     * @param sender       - The sender of this request.\\n     * @param nonce        - The nonce used in the request.\\n     */\\n    event UserOperationPrefundTooLow(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce\\n    );\\n\\n    /**\\n     * An event emitted by handleOps(), before starting the execution loop.\\n     * Any event emitted before this event, is part of the validation.\\n     */\\n    event BeforeExecution();\\n\\n    /**\\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\\n     */\\n    event SignatureAggregatorChanged(address indexed aggregator);\\n\\n    /**\\n     * A custom revert error of handleOps, to identify the offending op.\\n     * Should be caught in off-chain handleOps simulation and not happen on-chain.\\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\\n     * @param reason  - Revert reason. The string starts with a unique code \\\"AAmn\\\",\\n     *                  where \\\"m\\\" is \\\"1\\\" for factory, \\\"2\\\" for account and \\\"3\\\" for paymaster issues,\\n     *                  so a failure can be attributed to the correct entity.\\n     */\\n    error FailedOp(uint256 opIndex, string reason);\\n\\n    /**\\n     * A custom revert error of handleOps, to report a revert by account or paymaster.\\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\\n     * @param inner   - data from inner cought revert reason\\n     * @dev note that inner is truncated to 2048 bytes\\n     */\\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\\n\\n    error PostOpReverted(bytes returnData);\\n\\n    /**\\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\\n     * @param aggregator The aggregator that failed to verify the signature\\n     */\\n    error SignatureValidationFailed(address aggregator);\\n\\n    // Return value of getSenderAddress.\\n    error SenderAddressResult(address sender);\\n\\n    // UserOps handled, per aggregator.\\n    struct UserOpsPerAggregator {\\n        PackedUserOperation[] userOps;\\n        // Aggregator address\\n        IAggregator aggregator;\\n        // Aggregated signature\\n        bytes signature;\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperations.\\n     * No signature aggregator is used.\\n     * If any account requires an aggregator (that is, it returned an aggregator when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops         - The operations to execute.\\n     * @param beneficiary - The address to receive the fees.\\n     */\\n    function handleOps(\\n        PackedUserOperation[] calldata ops,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\\n     * @param beneficiary      - The address to receive the fees.\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * Generate a request Id - unique identifier for this request.\\n     * The request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     * @param userOp - The user operation to generate the request ID for.\\n     * @return hash the hash of this UserOperation\\n     */\\n    function getUserOpHash(\\n        PackedUserOperation calldata userOp\\n    ) external view returns (bytes32);\\n\\n    /**\\n     * Gas and return values during simulation.\\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\\n     * @param prefund          - The required prefund for this operation\\n     * @param accountValidationData   - returned validationData from account.\\n     * @param paymasterValidationData - return validationData from paymaster.\\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\\n     */\\n    struct ReturnInfo {\\n        uint256 preOpGas;\\n        uint256 prefund;\\n        uint256 accountValidationData;\\n        uint256 paymasterValidationData;\\n        bytes paymasterContext;\\n    }\\n\\n    /**\\n     * Returned aggregated signature info:\\n     * The aggregator returned by the account, and its current stake.\\n     */\\n    struct AggregatorStakeInfo {\\n        address aggregator;\\n        StakeInfo stakeInfo;\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * This method always revert, and returns the address in SenderAddressResult error\\n     * @param initCode - The constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode) external;\\n\\n    error DelegateAndRevert(bool success, bytes ret);\\n\\n    /**\\n     * Helper method for dry-run testing.\\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\\n     *  actual EntryPoint code is less convenient.\\n     * @param target a target contract to make a delegatecall from entrypoint\\n     * @param data data to pass to target in a delegatecall\\n     */\\n    function delegateAndRevert(address target, bytes calldata data) external;\\n}\\n\",\"keccak256\":\"0x1972a5fcb3a808b58c85af5741949ef6af11ab0debd3ae8c708171ae1ae0d0c4\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/INonceManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface INonceManager {\\n\\n    /**\\n     * Return the next nonce for this sender.\\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\\n     * But UserOp with different keys can come with arbitrary order.\\n     *\\n     * @param sender the account address\\n     * @param key the high 192 bit of the nonce\\n     * @return nonce a full nonce to pass for next UserOp with this sender.\\n     */\\n    function getNonce(address sender, uint192 key)\\n    external view returns (uint256 nonce);\\n\\n    /**\\n     * Manually increment the nonce of the sender.\\n     * This method is exposed just for completeness..\\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\\n     * as the EntryPoint will update the nonce regardless.\\n     * Possible use-case is call it with various keys to \\\"initialize\\\" their nonces to one, so that future\\n     * UserOperations will not pay extra for the first transaction with a given key.\\n     */\\n    function incrementNonce(uint192 key) external;\\n}\\n\",\"keccak256\":\"0xd575af0f6ebbd5f0b2933307d44cd7b4e03a69f4b817a67db5409bd3c89aeecb\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IStakeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.7.5;\\n\\n/**\\n * Manage deposits and stakes.\\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\\n * Stake is value locked for at least \\\"unstakeDelay\\\" by the staked entity.\\n */\\ninterface IStakeManager {\\n    event Deposited(address indexed account, uint256 totalDeposit);\\n\\n    event Withdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    // Emitted when stake or unstake delay are modified.\\n    event StakeLocked(\\n        address indexed account,\\n        uint256 totalStaked,\\n        uint256 unstakeDelaySec\\n    );\\n\\n    // Emitted once a stake is scheduled for withdrawal.\\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\\n\\n    event StakeWithdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @param deposit         - The entity's deposit.\\n     * @param staked          - True if this entity is staked.\\n     * @param stake           - Actual amount of ether staked for this entity.\\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\\n     *      - 112 bit allows for 10^15 eth\\n     *      - 48 bit for full timestamp\\n     *      - 32 bit allows 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint256 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint48 withdrawTime;\\n    }\\n\\n    // API struct used by getStakeInfo and simulateValidation.\\n    struct StakeInfo {\\n        uint256 stake;\\n        uint256 unstakeDelaySec;\\n    }\\n\\n    /**\\n     * Get deposit info.\\n     * @param account - The account to query.\\n     * @return info   - Full deposit information of given account.\\n     */\\n    function getDepositInfo(\\n        address account\\n    ) external view returns (DepositInfo memory info);\\n\\n    /**\\n     * Get account balance.\\n     * @param account - The account to query.\\n     * @return        - The deposit (for gas payment) of the account.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * Add to the deposit of the given account.\\n     * @param account - The account to add to.\\n     */\\n    function depositTo(address account) external payable;\\n\\n    /**\\n     * Add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param _unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 _unstakeDelaySec) external payable;\\n\\n    /**\\n     * Attempt to unlock the stake.\\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external;\\n\\n    /**\\n     * Withdraw from the (unlocked) stake.\\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\\n     * @param withdrawAddress - The address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external;\\n\\n    /**\\n     * Withdraw from the deposit.\\n     * @param withdrawAddress - The address to send withdrawn value.\\n     * @param withdrawAmount  - The amount to withdraw.\\n     */\\n    function withdrawTo(\\n        address payable withdrawAddress,\\n        uint256 withdrawAmount\\n    ) external;\\n}\\n\",\"keccak256\":\"0xbe5ca9e7f254d031687419e7b96ef48c9c63e9398bbe992dc72ffc6dc14e0a04\",\"license\":\"GPL-3.0-only\"},\"contracts/interfaces/PackedUserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\n/**\\n * User Operation struct\\n * @param sender                - The sender account of this request.\\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\\n * @param initCode              - If set, the account contract will be created by this constructor/\\n * @param callData              - The method call to execute on this account.\\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\\n *                                Covers batch overhead.\\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\\n *                                The paymaster will pay for the transaction instead of the sender.\\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct PackedUserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    bytes32 accountGasLimits;\\n    uint256 preVerificationGas;\\n    bytes32 gasFees;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0x1129b46381db68eddbc5cb49e50664667b66b03c480453858e7b25eabe444359\",\"license\":\"GPL-3.0\"},\"contracts/samples/SimpleTeamAccount.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"../core/BaseAccount.sol\\\";\\nimport \\\"../core/Helpers.sol\\\";\\nimport \\\"./callback/TokenCallbackHandler.sol\\\";\\n\\nimport {Initializable} from \\\"solady/src/utils/Initializable.sol\\\";\\nimport {ECDSA} from \\\"solady/src/utils/ECDSA.sol\\\";\\nimport {LibString} from \\\"solady/src/utils/LibString.sol\\\";\\nimport {WebAuthn} from \\\"solady/src/utils/WebAuthn.sol\\\";\\nimport {Base64} from \\\"solady/src/utils/Base64.sol\\\";\\nimport {EfficientHashLib} from \\\"solady/src/utils/EfficientHashLib.sol\\\";\\n\\nstruct Call {\\n    address target;\\n    uint256 value;\\n    bytes data;\\n}\\n\\nenum Access {\\n    Outsider,\\n    Member,\\n    Owner\\n}\\n\\n/**\\n * Data structure for storing the public credentials for a signer.\\n * If WebAuthn, pubKeySlt1 and pubKeySlt2 is the P256 x and y coordinates.\\n * If ECDSA, pubKeySlt1 is the padded address and pubKeySlt2 is 0.\\n */\\nstruct Signer {\\n    bytes32 pubKeySlt1;\\n    bytes32 pubKeySlt2;\\n    Access level;\\n}\\n\\n/**\\n * Minimal team account.\\n *  This is a simple account for teams that require a shared treasury.\\n *  It is lightweight by design and does not support modules or onchain permissions.\\n *  Any access control logic should be computed and signed offchain.\\n *\\n *  This implementation supports 4 signature types:\\n *      1. Owner with WebAuthn\\n *      2. Member with WebAuthn and verified with ECDSA\\n *      3. Owner with ECDSA\\n *      4. Member with ECDSA and verified with ECDSA\\n *\\n * SimpleTeamAccount is originally forked from SimpleAccount.\\n * The execute and executeBatch functions are modified from Solady.\\n */\\ncontract SimpleTeamAccount is BaseAccount, TokenCallbackHandler, Initializable {\\n    using LibString for string;\\n\\n    address public verifier;\\n    mapping(bytes32 id => Signer s) internal signers;\\n\\n    IEntryPoint private immutable _entryPoint;\\n\\n    event SimpleTeamAccountInitialized(IEntryPoint indexed entryPoint);\\n    event SimpleTeamAccountSignerSet(bytes32 signerId);\\n    event SimpleTeamAccountSignerDeleted(bytes32 signerId);\\n    event SimpleTeamAccountVerifierSet(address verifier);\\n\\n    modifier onlySelf() {\\n        _onlySelf();\\n        _;\\n    }\\n\\n    /// @inheritdoc BaseAccount\\n    function entryPoint() public view virtual override returns (IEntryPoint) {\\n        return _entryPoint;\\n    }\\n\\n    function getSigner(bytes32 signerId) public view returns (Signer memory) {\\n        return signers[signerId];\\n    }\\n\\n    function getSignerId(bytes32 pubKeySlt1, bytes32 pubKeySlt2) public pure returns (bytes32) {\\n        return EfficientHashLib.hash(pubKeySlt1, pubKeySlt2);\\n    }\\n\\n    function getVerifierHash(bytes32 userOpHash, bytes32 signerId) public pure returns (bytes32) {\\n        return EfficientHashLib.hash(userOpHash, signerId);\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {}\\n\\n    constructor(IEntryPoint anEntryPoint) {\\n        _entryPoint = anEntryPoint;\\n        _disableInitializers();\\n    }\\n\\n    function _onlySelf() internal view {\\n        // directly from the account itself (which gets redirected through execute())\\n        require(msg.sender == address(this), \\\"only self\\\");\\n    }\\n\\n    /**\\n     * execute a transaction\\n     * @param target destination address to call\\n     * @param value the value to pass in this call\\n     * @param data the calldata to pass in this call\\n     */\\n    function execute(address target, uint256 value, bytes calldata data) external returns (bytes memory result) {\\n        _requireFromEntryPoint();\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, data.offset, data.length)\\n            if iszero(call(gas(), target, value, result, data.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    /**\\n     * execute a sequence of transactions\\n     * @param calls an array of calls to make from this account\\n     */\\n    function executeBatch(Call[] calldata calls) external returns (bytes[] memory results) {\\n        _requireFromEntryPoint();\\n        assembly {\\n            results := mload(0x40)\\n            mstore(results, calls.length)\\n            let r := add(0x20, results)\\n            let m := add(r, shl(5, calls.length))\\n            calldatacopy(r, calls.offset, shl(5, calls.length))\\n            for { let end := m } iszero(eq(r, end)) { r := add(r, 0x20) } {\\n                let e := add(calls.offset, mload(r))\\n                let o := add(e, calldataload(add(e, 0x40)))\\n                calldatacopy(m, add(o, 0x20), calldataload(o))\\n                // forgefmt: disable-next-item\\n                if iszero(call(gas(), calldataload(e), calldataload(add(e, 0x20)),\\n                    m, calldataload(o), codesize(), 0x00)) {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n                mstore(r, m) // Append `m` into `results`.\\n                mstore(m, returndatasize()) // Store the length,\\n                let p := add(m, 0x20)\\n                returndatacopy(p, 0x00, returndatasize()) // and copy the returndata.\\n                m := add(p, returndatasize()) // Advance `m`.\\n            }\\n            mstore(0x40, m) // Allocate the memory.\\n        }\\n    }\\n\\n    /**\\n     * Sets a new WebAuthn signer or overrides an existing one on the account.\\n     * @param x The P256 x coordinate of the public key.\\n     * @param y The P256 y coordinate of the public key.\\n     * @param level The access level for the signer.\\n     */\\n    function setWebAuthnSigner(bytes32 x, bytes32 y, Access level) external onlySelf {\\n        Signer memory s = Signer(x, y, level);\\n        _setSigner(s);\\n    }\\n\\n    /**\\n     * Sets a new ECDSA signer or overrides an existing one on the account.\\n     * @param ecdsa The signer address.\\n     * @param level The access level for the signer.\\n     */\\n    function setECDSASigner(address ecdsa, Access level) external onlySelf {\\n        Signer memory s = Signer(bytes32(uint256(uint160(ecdsa))), 0, level);\\n        _setSigner(s);\\n    }\\n\\n    /**\\n     * Deletes a signer from the account.\\n     * @param signerId The id of the signer to remove.\\n     */\\n    function deleteSigner(bytes32 signerId) external onlySelf {\\n        delete signers[signerId];\\n        emit SimpleTeamAccountSignerDeleted(signerId);\\n    }\\n\\n    /**\\n     * Sets a new verifier for approving member level transactions.\\n     * @param aVerifier The address for the new verifying entity.\\n     */\\n    function setVerifier(address aVerifier) external onlySelf {\\n        _setVerifier(aVerifier);\\n    }\\n\\n    /**\\n     * @dev The _entryPoint member is immutable, to reduce gas consumption.\\n     * @param initSigner the owner (signer) of this account\\n     * @param initVerifier An authorized entity for approving member level transactions.\\n     */\\n    function initialize(Signer calldata initSigner, address initVerifier) public virtual initializer {\\n        _initialize(initSigner, initVerifier);\\n    }\\n\\n    function _initialize(Signer calldata initSigner, address initVerifier) internal virtual {\\n        _setSigner(initSigner);\\n        _setVerifier(initVerifier);\\n        emit SimpleTeamAccountInitialized(_entryPoint);\\n    }\\n\\n    function _setSigner(Signer memory signer) internal {\\n        bytes32 id = EfficientHashLib.hash(signer.pubKeySlt1, signer.pubKeySlt2);\\n        signers[id] = signer;\\n        emit SimpleTeamAccountSignerSet(id);\\n    }\\n\\n    function _setVerifier(address aVerifier) internal {\\n        verifier = aVerifier;\\n        emit SimpleTeamAccountVerifierSet(aVerifier);\\n    }\\n\\n    function _validateSignature(PackedUserOperation calldata userOp, bytes32 userOpHash)\\n        internal\\n        virtual\\n        override\\n        returns (uint256 validationData)\\n    {\\n        bytes32 signerId = bytes32(userOp.signature[:32]);\\n        Signer memory signer = signers[signerId];\\n        require(signer.level != Access.Outsider, \\\"account: unauthorized\\\");\\n\\n        // Assuming WebAuthn signature.\\n        bytes calldata data = userOp.signature[32:];\\n        if (signer.pubKeySlt2 != 0) {\\n            if (signer.level == Access.Owner) {\\n                return _validateWebAuthnOwner(signer, userOpHash, data);\\n            }\\n\\n            return _validateWebAuthnMember(signer, userOpHash, getVerifierHash(userOpHash, signerId), data);\\n        }\\n\\n        // Assuming ECDSA signature.\\n        if (signer.level == Access.Owner) {\\n            return _validateECDSAOwner(signer, userOpHash, data);\\n        }\\n        return _validateECDSAMember(signer, userOpHash, getVerifierHash(userOpHash, signerId), data);\\n    }\\n\\n    function _validateWebAuthnOwner(Signer memory signer, bytes32 userOpHash, bytes calldata data)\\n        internal\\n        view\\n        returns (uint256 validationData)\\n    {\\n        bytes memory challenge = abi.encode(userOpHash);\\n        WebAuthn.WebAuthnAuth memory auth = _webAuthn(challenge, data);\\n        return WebAuthn.verify(challenge, true, auth, signer.pubKeySlt1, signer.pubKeySlt2)\\n            ? SIG_VALIDATION_SUCCESS\\n            : SIG_VALIDATION_FAILED;\\n    }\\n\\n    function _validateECDSAOwner(Signer memory signer, bytes32 userOpHash, bytes calldata data)\\n        internal\\n        view\\n        returns (uint256 validationData)\\n    {\\n        return address(uint160(uint256(signer.pubKeySlt1)))\\n            == ECDSA.recover(ECDSA.toEthSignedMessageHash(userOpHash), data)\\n            ? SIG_VALIDATION_SUCCESS\\n            : SIG_VALIDATION_FAILED;\\n    }\\n\\n    function _validateWebAuthnMember(\\n        Signer memory signer,\\n        bytes32 userOpHash,\\n        bytes32 verifierHash,\\n        bytes calldata data\\n    ) internal view returns (uint256 validationData) {\\n        bytes memory challenge = abi.encode(userOpHash);\\n        WebAuthn.WebAuthnAuth memory auth = _webAuthn(challenge, data[65:]);\\n\\n        bool verifierOk = verifier == ECDSA.recover(ECDSA.toEthSignedMessageHash(verifierHash), data[:65]);\\n        bool signerOk = WebAuthn.verify(challenge, true, auth, signer.pubKeySlt1, signer.pubKeySlt2);\\n        return verifierOk && signerOk ? SIG_VALIDATION_SUCCESS : SIG_VALIDATION_FAILED;\\n    }\\n\\n    function _validateECDSAMember(Signer memory signer, bytes32 userOpHash, bytes32 verifierHash, bytes calldata data)\\n        internal\\n        view\\n        returns (uint256 validationData)\\n    {\\n        bool verifierOk = verifier == ECDSA.recover(ECDSA.toEthSignedMessageHash(verifierHash), data[:65]);\\n        bool signerOk = address(uint160(uint256(signer.pubKeySlt1)))\\n            == ECDSA.recover(ECDSA.toEthSignedMessageHash(userOpHash), data[65:]);\\n        return verifierOk && signerOk ? SIG_VALIDATION_SUCCESS : SIG_VALIDATION_FAILED;\\n    }\\n\\n    function _webAuthn(bytes memory challenge, bytes memory data)\\n        internal\\n        pure\\n        returns (WebAuthn.WebAuthnAuth memory auth)\\n    {\\n        (\\n            bytes memory authenticatorData,\\n            string memory clientDataJSONPre,\\n            string memory clientDataJSONPost,\\n            uint256 challengeIndex,\\n            uint256 typeIndex,\\n            bytes32 r,\\n            bytes32 s\\n        ) = abi.decode(data, (bytes, string, string, uint256, uint256, bytes32, bytes32));\\n        auth = WebAuthn.WebAuthnAuth({\\n            authenticatorData: authenticatorData,\\n            clientDataJSON: clientDataJSONPre.concat(Base64.encode(challenge, true, true)).concat(clientDataJSONPost),\\n            challengeIndex: challengeIndex,\\n            typeIndex: typeIndex,\\n            r: r,\\n            s: s\\n        });\\n    }\\n}\\n\",\"keccak256\":\"0x6b0b29807e9d4eda98e37bf82f0d8715fa6a5336a58f3e9a2c6889030b6655a9\",\"license\":\"GPL-3.0\"},\"contracts/samples/SimpleTeamAccountFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\n\\nimport \\\"./SimpleTeamAccount.sol\\\";\\n\\n/**\\n * The factory contract for SimpleTeamAccount.\\n *\\n * SimpleTeamAccountFactory is originally forked from SimpleAccountFactory.\\n */\\ncontract SimpleTeamAccountFactory {\\n    SimpleTeamAccount public immutable accountImplementation;\\n\\n    constructor(IEntryPoint _entryPoint) {\\n        accountImplementation = new SimpleTeamAccount(_entryPoint);\\n    }\\n\\n    /**\\n     * create an account, and return its address.\\n     * returns the address even if the account is already deployed.\\n     * Note that during UserOperation execution, this method is called only if the account is not deployed.\\n     * This method returns an existing account address so that entryPoint.getSenderAddress() would work even after account creation\\n     */\\n    function createAccount(Signer calldata signer, address verifier, uint256 salt)\\n        public\\n        returns (SimpleTeamAccount ret)\\n    {\\n        address addr = getAddress(signer, verifier, salt);\\n        uint256 codeSize = addr.code.length;\\n        if (codeSize > 0) {\\n            return SimpleTeamAccount(payable(addr));\\n        }\\n        ret = SimpleTeamAccount(\\n            payable(\\n                new ERC1967Proxy{salt: bytes32(salt)}(\\n                    address(accountImplementation), abi.encodeCall(SimpleTeamAccount.initialize, (signer, verifier))\\n                )\\n            )\\n        );\\n    }\\n\\n    /**\\n     * calculate the counterfactual address of this account as it would be returned by createAccount()\\n     */\\n    function getAddress(Signer calldata signer, address verifier, uint256 salt) public view returns (address) {\\n        return Create2.computeAddress(\\n            bytes32(salt),\\n            keccak256(\\n                abi.encodePacked(\\n                    type(ERC1967Proxy).creationCode,\\n                    abi.encode(\\n                        address(accountImplementation), abi.encodeCall(SimpleTeamAccount.initialize, (signer, verifier))\\n                    )\\n                )\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xb3419a97c813f8db42c12895f0fadfef09e6d2443454a72f2ba8bc507711844f\",\"license\":\"GPL-3.0\"},\"contracts/samples/callback/TokenCallbackHandler.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-empty-blocks */\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\n\\n/**\\n * Token callback handler.\\n *   Handles supported tokens' callbacks, allowing account receiving these tokens.\\n */\\nabstract contract TokenCallbackHandler is IERC721Receiver, IERC1155Receiver {\\n\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return IERC1155Receiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\\n        return\\n            interfaceId == type(IERC721Receiver).interfaceId ||\\n            interfaceId == type(IERC1155Receiver).interfaceId ||\\n            interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x7770340a57c4be2b718b6ac2b031722074c0d795e0f4e1a6740ca1aa3d85e9d7\",\"license\":\"GPL-3.0\"},\"solady/src/utils/Base64.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library to encode strings in Base64.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\\nlibrary Base64 {\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\n    /// @param noPadding Whether to strip away the padding.\\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                // Multiply by 4/3 rounded up.\\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\\n\\n                // Set `result` to point to the start of the free memory.\\n                result := mload(0x40)\\n\\n                // Store the table into the scratch space.\\n                // Offsetted by -1 byte so that the `mload` will load the character.\\n                // We will rewrite the free memory pointer at `0x40` later with\\n                // the allocated size.\\n                // The magic constant 0x0670 will turn \\\"-_\\\" into \\\"+/\\\".\\n                mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\n                mstore(0x3f, xor(\\\"ghijklmnopqrstuvwxyz0123456789-_\\\", mul(iszero(fileSafe), 0x0670)))\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, encodedLength)\\n\\n                let dataEnd := add(add(0x20, data), dataLength)\\n                let dataEndValue := mload(dataEnd) // Cache the value at the `dataEnd` slot.\\n                mstore(dataEnd, 0x00) // Zeroize the `dataEnd` slot to clear dirty bits.\\n\\n                // Run over the input, 3 bytes at a time.\\n                for {} 1 {} {\\n                    data := add(data, 3) // Advance 3 bytes.\\n                    let input := mload(data)\\n\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\\n                    mstore8(3, mload(and(input, 0x3F)))\\n                    mstore(ptr, mload(0x00))\\n\\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n                mstore(dataEnd, dataEndValue) // Restore the cached value at `dataEnd`.\\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\\n                let o := div(2, mod(dataLength, 3))\\n                // Offset `ptr` and pad with '='. We can simply write over the end.\\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\\n                // Set `o` to zero if there is padding.\\n                o := mul(iszero(iszero(noPadding)), o)\\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\\n                mstore(result, sub(encodedLength, o)) // Store the length.\\n            }\\n        }\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, false, false)`.\\n    function encode(bytes memory data) internal pure returns (string memory result) {\\n        result = encode(data, false, false);\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, fileSafe, false)`.\\n    function encode(bytes memory data, bool fileSafe)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = encode(data, fileSafe, false);\\n    }\\n\\n    /// @dev Decodes base64 encoded `data`.\\n    ///\\n    /// Supports:\\n    /// - RFC 4648 (both standard and file-safe mode).\\n    /// - RFC 3501 (63: ',').\\n    ///\\n    /// Does not support:\\n    /// - Line breaks.\\n    ///\\n    /// Note: For performance reasons,\\n    /// this function will NOT revert on invalid `data` inputs.\\n    /// Outputs for invalid inputs will simply be undefined behaviour.\\n    /// It is the user's responsibility to ensure that the `data`\\n    /// is a valid base64 encoded string.\\n    function decode(string memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                let decodedLength := mul(shr(2, dataLength), 3)\\n\\n                for {} 1 {} {\\n                    // If padded.\\n                    if iszero(and(dataLength, 3)) {\\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\\n                        // forgefmt: disable-next-item\\n                        decodedLength := sub(\\n                            decodedLength,\\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\\n                        )\\n                        break\\n                    }\\n                    // If non-padded.\\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\\n                    break\\n                }\\n                result := mload(0x40)\\n\\n                // Write the length of the bytes.\\n                mstore(result, decodedLength)\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, decodedLength)\\n\\n                // Load the table into the scratch space.\\n                // Constants are optimized for smaller bytecode with zero gas overhead.\\n                // `m` also doubles as the mask of the upper 6 bits.\\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\\n                mstore(0x5b, m)\\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\\n\\n                for {} 1 {} {\\n                    // Read 4 bytes.\\n                    data := add(data, 4)\\n                    let input := mload(data)\\n\\n                    // Write 3 bytes.\\n                    // forgefmt: disable-next-item\\n                    mstore(ptr, or(\\n                        and(m, mload(byte(28, input))),\\n                        shr(6, or(\\n                            and(m, mload(byte(29, input))),\\n                            shr(6, or(\\n                                and(m, mload(byte(30, input))),\\n                                shr(6, mload(byte(31, input)))\\n                            ))\\n                        ))\\n                    ))\\n                    ptr := add(ptr, 3)\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\\n                mstore(end, 0) // Zeroize the slot after the bytes.\\n                mstore(0x60, 0) // Restore the zero slot.\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x07dcf983a86bc961e4cc0b57a2cfc3e46b20a50fed9b2092c7497e5fe3715a93\",\"license\":\"MIT\"},\"solady/src/utils/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized ECDSA wrapper.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\\n///\\n/// @dev Note:\\n/// - The recovery functions use the ecrecover precompile (0x1).\\n/// - As of Solady version 0.0.68, the `recover` variants will revert upon recovery failure.\\n///   This is for more safety by default.\\n///   Use the `tryRecover` variants if you need to get the zero address back\\n///   upon recovery failure instead.\\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\\n///   See: https://eips.ethereum.org/EIPS/eip-2098\\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\\n///\\n/// WARNING! Do NOT directly use signatures as unique identifiers:\\n/// - The recovery operations do NOT check if a signature is non-malleable.\\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\\n///   EIP-712 also enables readable signing of typed data for better user safety.\\n/// - If you need a unique hash from a signature, please use the `canonicalHash` functions.\\nlibrary ECDSA {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The order of the secp256k1 elliptic curve.\\n    uint256 internal constant N = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141;\\n\\n    /// @dev `N/2 + 1`. Used for checking the malleability of the signature.\\n    uint256 private constant _HALF_N_PLUS_1 =\\n        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The signature is invalid.\\n    error InvalidSignature();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                    RECOVERY OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let m := mload(0x40) } 1 {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            } {\\n                switch mload(signature)\\n                case 64 {\\n                    let vs := mload(add(signature, 0x40))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                }\\n                case 65 {\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                }\\n                default { continue }\\n                mstore(0x00, hash)\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                if returndatasize() { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let m := mload(0x40) } 1 {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            } {\\n                switch signature.length\\n                case 64 {\\n                    let vs := calldataload(add(signature.offset, 0x20))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                }\\n                case 65 {\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n                }\\n                default { continue }\\n                mstore(0x00, hash)\\n                result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                if returndatasize() { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   TRY-RECOVER OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // WARNING!\\n    // These functions will NOT revert upon recovery failure.\\n    // Instead, they will return the zero address upon recovery failure.\\n    // It is critical that the returned address is NEVER compared against\\n    // a zero address (e.g. an uninitialized address variable).\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function tryRecover(bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let m := mload(0x40) } 1 {} {\\n                switch mload(signature)\\n                case 64 {\\n                    let vs := mload(add(signature, 0x40))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                }\\n                case 65 {\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                }\\n                default { break }\\n                mstore(0x00, hash)\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\\n                mstore(0x60, 0) // Restore the zero slot.\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                result := mload(xor(0x60, returndatasize()))\\n                mstore(0x40, m) // Restore the free memory pointer.\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let m := mload(0x40) } 1 {} {\\n                switch signature.length\\n                case 64 {\\n                    let vs := calldataload(add(signature.offset, 0x20))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                }\\n                case 65 {\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n                }\\n                default { break }\\n                mstore(0x00, hash)\\n                pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\\n                mstore(0x60, 0) // Restore the zero slot.\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                result := mload(xor(0x60, returndatasize()))\\n                mstore(0x40, m) // Restore the free memory pointer.\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\n        }\\n    }\\n\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let sLength := mload(s)\\n            let o := 0x20\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\n            mstore(0x00, 0x00)\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\n            for { let temp := sLength } 1 {} {\\n                o := sub(o, 1)\\n                mstore8(o, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\n            mstore(s, sLength) // Restore the length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  CANONICAL HASH FUNCTIONS                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // The following functions returns the hash of the signature in it's canonicalized format,\\n    // which is the 65-byte `abi.encodePacked(r, s, uint8(v))`, where `v` is either 27 or 28.\\n    // If `s` is greater than `N / 2` then it will be converted to `N - s`\\n    // and the `v` value will be flipped.\\n    // If the signature has an invalid length, or if `v` is invalid,\\n    // a uniquely corrupt hash will be returned.\\n    // These functions are useful for \\\"poor-mans-VRF\\\".\\n\\n    /// @dev Returns the canonical hash of `signature`.\\n    function canonicalHash(bytes memory signature) internal pure returns (bytes32 result) {\\n        // @solidity memory-safe-assembly\\n        assembly {\\n            let l := mload(signature)\\n            for {} 1 {} {\\n                mstore(0x00, mload(add(signature, 0x20))) // `r`.\\n                let s := mload(add(signature, 0x40))\\n                let v := mload(add(signature, 0x41))\\n                if eq(l, 64) {\\n                    v := add(shr(255, s), 27)\\n                    s := shr(1, shl(1, s))\\n                }\\n                if iszero(lt(s, _HALF_N_PLUS_1)) {\\n                    v := xor(v, 7)\\n                    s := sub(N, s)\\n                }\\n                mstore(0x21, v)\\n                mstore(0x20, s)\\n                result := keccak256(0x00, 0x41)\\n                mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n                break\\n            }\\n\\n            // If the length is neither 64 nor 65, return a uniquely corrupted hash.\\n            if iszero(lt(sub(l, 64), 2)) {\\n                // `bytes4(keccak256(\\\"InvalidSignatureLength\\\"))`.\\n                result := xor(keccak256(add(signature, 0x20), l), 0xd62f1ab2)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the canonical hash of `signature`.\\n    function canonicalHashCalldata(bytes calldata signature)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        // @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                mstore(0x00, calldataload(signature.offset)) // `r`.\\n                let s := calldataload(add(signature.offset, 0x20))\\n                let v := calldataload(add(signature.offset, 0x21))\\n                if eq(signature.length, 64) {\\n                    v := add(shr(255, s), 27)\\n                    s := shr(1, shl(1, s))\\n                }\\n                if iszero(lt(s, _HALF_N_PLUS_1)) {\\n                    v := xor(v, 7)\\n                    s := sub(N, s)\\n                }\\n                mstore(0x21, v)\\n                mstore(0x20, s)\\n                result := keccak256(0x00, 0x41)\\n                mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n                break\\n            }\\n            // If the length is neither 64 nor 65, return a uniquely corrupted hash.\\n            if iszero(lt(sub(signature.length, 64), 2)) {\\n                calldatacopy(mload(0x40), signature.offset, signature.length)\\n                // `bytes4(keccak256(\\\"InvalidSignatureLength\\\"))`.\\n                result := xor(keccak256(mload(0x40), signature.length), 0xd62f1ab2)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the canonical hash of `signature`.\\n    function canonicalHash(bytes32 r, bytes32 vs) internal pure returns (bytes32 result) {\\n        // @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, r) // `r`.\\n            let v := add(shr(255, vs), 27)\\n            let s := shr(1, shl(1, vs))\\n            mstore(0x21, v)\\n            mstore(0x20, s)\\n            result := keccak256(0x00, 0x41)\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the canonical hash of `signature`.\\n    function canonicalHash(uint8 v, bytes32 r, bytes32 s) internal pure returns (bytes32 result) {\\n        // @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, r) // `r`.\\n            if iszero(lt(s, _HALF_N_PLUS_1)) {\\n                v := xor(v, 7)\\n                s := sub(N, s)\\n            }\\n            mstore(0x21, v)\\n            mstore(0x20, s)\\n            result := keccak256(0x00, 0x41)\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes.\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            signature.length := 0\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5a37fbc86ff99139e1cffad4ec05ffeeef17c1d1401113f107665d08a6abe7df\",\"license\":\"MIT\"},\"solady/src/utils/EfficientHashLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for efficiently performing keccak256 hashes.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EfficientHashLib.sol)\\n/// @dev To avoid stack-too-deep, you can use:\\n/// ```\\n/// bytes32[] memory buffer = EfficientHashLib.malloc(10);\\n/// EfficientHashLib.set(buffer, 0, value0);\\n/// ..\\n/// EfficientHashLib.set(buffer, 9, value9);\\n/// bytes32 finalHash = EfficientHashLib.hash(buffer);\\n/// ```\\nlibrary EfficientHashLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*               MALLOC-LESS HASHING OPERATIONS               */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns `keccak256(abi.encode(v0))`.\\n    function hash(bytes32 v0) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, v0)\\n            result := keccak256(0x00, 0x20)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0))`.\\n    function hash(uint256 v0) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, v0)\\n            result := keccak256(0x00, 0x20)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, v1))`.\\n    function hash(bytes32 v0, bytes32 v1) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, v0)\\n            mstore(0x20, v1)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, v1))`.\\n    function hash(uint256 v0, uint256 v1) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, v0)\\n            mstore(0x20, v1)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2))`.\\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            result := keccak256(m, 0x60)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2))`.\\n    function hash(uint256 v0, uint256 v1, uint256 v2) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            result := keccak256(m, 0x60)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2, v3))`.\\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            result := keccak256(m, 0x80)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2, v3))`.\\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            result := keccak256(m, 0x80)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v4))`.\\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            result := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v4))`.\\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            result := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v5))`.\\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            result := keccak256(m, 0xc0)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v5))`.\\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            result := keccak256(m, 0xc0)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v6))`.\\n    function hash(\\n        bytes32 v0,\\n        bytes32 v1,\\n        bytes32 v2,\\n        bytes32 v3,\\n        bytes32 v4,\\n        bytes32 v5,\\n        bytes32 v6\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            result := keccak256(m, 0xe0)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v6))`.\\n    function hash(\\n        uint256 v0,\\n        uint256 v1,\\n        uint256 v2,\\n        uint256 v3,\\n        uint256 v4,\\n        uint256 v5,\\n        uint256 v6\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            result := keccak256(m, 0xe0)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v7))`.\\n    function hash(\\n        bytes32 v0,\\n        bytes32 v1,\\n        bytes32 v2,\\n        bytes32 v3,\\n        bytes32 v4,\\n        bytes32 v5,\\n        bytes32 v6,\\n        bytes32 v7\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            mstore(add(m, 0xe0), v7)\\n            result := keccak256(m, 0x100)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v7))`.\\n    function hash(\\n        uint256 v0,\\n        uint256 v1,\\n        uint256 v2,\\n        uint256 v3,\\n        uint256 v4,\\n        uint256 v5,\\n        uint256 v6,\\n        uint256 v7\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            mstore(add(m, 0xe0), v7)\\n            result := keccak256(m, 0x100)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v8))`.\\n    function hash(\\n        bytes32 v0,\\n        bytes32 v1,\\n        bytes32 v2,\\n        bytes32 v3,\\n        bytes32 v4,\\n        bytes32 v5,\\n        bytes32 v6,\\n        bytes32 v7,\\n        bytes32 v8\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            mstore(add(m, 0xe0), v7)\\n            mstore(add(m, 0x100), v8)\\n            result := keccak256(m, 0x120)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v8))`.\\n    function hash(\\n        uint256 v0,\\n        uint256 v1,\\n        uint256 v2,\\n        uint256 v3,\\n        uint256 v4,\\n        uint256 v5,\\n        uint256 v6,\\n        uint256 v7,\\n        uint256 v8\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            mstore(add(m, 0xe0), v7)\\n            mstore(add(m, 0x100), v8)\\n            result := keccak256(m, 0x120)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v9))`.\\n    function hash(\\n        bytes32 v0,\\n        bytes32 v1,\\n        bytes32 v2,\\n        bytes32 v3,\\n        bytes32 v4,\\n        bytes32 v5,\\n        bytes32 v6,\\n        bytes32 v7,\\n        bytes32 v8,\\n        bytes32 v9\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            mstore(add(m, 0xe0), v7)\\n            mstore(add(m, 0x100), v8)\\n            mstore(add(m, 0x120), v9)\\n            result := keccak256(m, 0x140)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v9))`.\\n    function hash(\\n        uint256 v0,\\n        uint256 v1,\\n        uint256 v2,\\n        uint256 v3,\\n        uint256 v4,\\n        uint256 v5,\\n        uint256 v6,\\n        uint256 v7,\\n        uint256 v8,\\n        uint256 v9\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            mstore(add(m, 0xe0), v7)\\n            mstore(add(m, 0x100), v8)\\n            mstore(add(m, 0x120), v9)\\n            result := keccak256(m, 0x140)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v10))`.\\n    function hash(\\n        bytes32 v0,\\n        bytes32 v1,\\n        bytes32 v2,\\n        bytes32 v3,\\n        bytes32 v4,\\n        bytes32 v5,\\n        bytes32 v6,\\n        bytes32 v7,\\n        bytes32 v8,\\n        bytes32 v9,\\n        bytes32 v10\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            mstore(add(m, 0xe0), v7)\\n            mstore(add(m, 0x100), v8)\\n            mstore(add(m, 0x120), v9)\\n            mstore(add(m, 0x140), v10)\\n            result := keccak256(m, 0x160)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v10))`.\\n    function hash(\\n        uint256 v0,\\n        uint256 v1,\\n        uint256 v2,\\n        uint256 v3,\\n        uint256 v4,\\n        uint256 v5,\\n        uint256 v6,\\n        uint256 v7,\\n        uint256 v8,\\n        uint256 v9,\\n        uint256 v10\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            mstore(add(m, 0xe0), v7)\\n            mstore(add(m, 0x100), v8)\\n            mstore(add(m, 0x120), v9)\\n            mstore(add(m, 0x140), v10)\\n            result := keccak256(m, 0x160)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v11))`.\\n    function hash(\\n        bytes32 v0,\\n        bytes32 v1,\\n        bytes32 v2,\\n        bytes32 v3,\\n        bytes32 v4,\\n        bytes32 v5,\\n        bytes32 v6,\\n        bytes32 v7,\\n        bytes32 v8,\\n        bytes32 v9,\\n        bytes32 v10,\\n        bytes32 v11\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            mstore(add(m, 0xe0), v7)\\n            mstore(add(m, 0x100), v8)\\n            mstore(add(m, 0x120), v9)\\n            mstore(add(m, 0x140), v10)\\n            mstore(add(m, 0x160), v11)\\n            result := keccak256(m, 0x180)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v11))`.\\n    function hash(\\n        uint256 v0,\\n        uint256 v1,\\n        uint256 v2,\\n        uint256 v3,\\n        uint256 v4,\\n        uint256 v5,\\n        uint256 v6,\\n        uint256 v7,\\n        uint256 v8,\\n        uint256 v9,\\n        uint256 v10,\\n        uint256 v11\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            mstore(add(m, 0xe0), v7)\\n            mstore(add(m, 0x100), v8)\\n            mstore(add(m, 0x120), v9)\\n            mstore(add(m, 0x140), v10)\\n            mstore(add(m, 0x160), v11)\\n            result := keccak256(m, 0x180)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v12))`.\\n    function hash(\\n        bytes32 v0,\\n        bytes32 v1,\\n        bytes32 v2,\\n        bytes32 v3,\\n        bytes32 v4,\\n        bytes32 v5,\\n        bytes32 v6,\\n        bytes32 v7,\\n        bytes32 v8,\\n        bytes32 v9,\\n        bytes32 v10,\\n        bytes32 v11,\\n        bytes32 v12\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            mstore(add(m, 0xe0), v7)\\n            mstore(add(m, 0x100), v8)\\n            mstore(add(m, 0x120), v9)\\n            mstore(add(m, 0x140), v10)\\n            mstore(add(m, 0x160), v11)\\n            mstore(add(m, 0x180), v12)\\n            result := keccak256(m, 0x1a0)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v12))`.\\n    function hash(\\n        uint256 v0,\\n        uint256 v1,\\n        uint256 v2,\\n        uint256 v3,\\n        uint256 v4,\\n        uint256 v5,\\n        uint256 v6,\\n        uint256 v7,\\n        uint256 v8,\\n        uint256 v9,\\n        uint256 v10,\\n        uint256 v11,\\n        uint256 v12\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            mstore(add(m, 0xe0), v7)\\n            mstore(add(m, 0x100), v8)\\n            mstore(add(m, 0x120), v9)\\n            mstore(add(m, 0x140), v10)\\n            mstore(add(m, 0x160), v11)\\n            mstore(add(m, 0x180), v12)\\n            result := keccak256(m, 0x1a0)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v13))`.\\n    function hash(\\n        bytes32 v0,\\n        bytes32 v1,\\n        bytes32 v2,\\n        bytes32 v3,\\n        bytes32 v4,\\n        bytes32 v5,\\n        bytes32 v6,\\n        bytes32 v7,\\n        bytes32 v8,\\n        bytes32 v9,\\n        bytes32 v10,\\n        bytes32 v11,\\n        bytes32 v12,\\n        bytes32 v13\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            mstore(add(m, 0xe0), v7)\\n            mstore(add(m, 0x100), v8)\\n            mstore(add(m, 0x120), v9)\\n            mstore(add(m, 0x140), v10)\\n            mstore(add(m, 0x160), v11)\\n            mstore(add(m, 0x180), v12)\\n            mstore(add(m, 0x1a0), v13)\\n            result := keccak256(m, 0x1c0)\\n        }\\n    }\\n\\n    /// @dev Returns `keccak256(abi.encode(v0, .., v13))`.\\n    function hash(\\n        uint256 v0,\\n        uint256 v1,\\n        uint256 v2,\\n        uint256 v3,\\n        uint256 v4,\\n        uint256 v5,\\n        uint256 v6,\\n        uint256 v7,\\n        uint256 v8,\\n        uint256 v9,\\n        uint256 v10,\\n        uint256 v11,\\n        uint256 v12,\\n        uint256 v13\\n    ) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, v0)\\n            mstore(add(m, 0x20), v1)\\n            mstore(add(m, 0x40), v2)\\n            mstore(add(m, 0x60), v3)\\n            mstore(add(m, 0x80), v4)\\n            mstore(add(m, 0xa0), v5)\\n            mstore(add(m, 0xc0), v6)\\n            mstore(add(m, 0xe0), v7)\\n            mstore(add(m, 0x100), v8)\\n            mstore(add(m, 0x120), v9)\\n            mstore(add(m, 0x140), v10)\\n            mstore(add(m, 0x160), v11)\\n            mstore(add(m, 0x180), v12)\\n            mstore(add(m, 0x1a0), v13)\\n            result := keccak256(m, 0x1c0)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*             BYTES32 BUFFER HASHING OPERATIONS              */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns `keccak256(abi.encode(buffer[0], .., buffer[buffer.length - 1]))`.\\n    function hash(bytes32[] memory buffer) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := keccak256(add(buffer, 0x20), shl(5, mload(buffer)))\\n        }\\n    }\\n\\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\\n    /// Returns the `buffer` for function chaining.\\n    function set(bytes32[] memory buffer, uint256 i, bytes32 value)\\n        internal\\n        pure\\n        returns (bytes32[] memory)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(add(buffer, shl(5, add(1, i))), value)\\n        }\\n        return buffer;\\n    }\\n\\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\\n    /// Returns the `buffer` for function chaining.\\n    function set(bytes32[] memory buffer, uint256 i, uint256 value)\\n        internal\\n        pure\\n        returns (bytes32[] memory)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(add(buffer, shl(5, add(1, i))), value)\\n        }\\n        return buffer;\\n    }\\n\\n    /// @dev Returns `new bytes32[](n)`, without zeroing out the memory.\\n    function malloc(uint256 n) internal pure returns (bytes32[] memory buffer) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            buffer := mload(0x40)\\n            mstore(buffer, n)\\n            mstore(0x40, add(shl(5, add(1, n)), buffer))\\n        }\\n    }\\n\\n    /// @dev Frees memory that has been allocated for `buffer`.\\n    /// No-op if `buffer.length` is zero, or if new memory has been allocated after `buffer`.\\n    function free(bytes32[] memory buffer) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(buffer)\\n            mstore(shl(6, lt(iszero(n), eq(add(shl(5, add(1, n)), buffer), mload(0x40)))), buffer)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      EQUALITY CHECKS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns `a == abi.decode(b, (bytes32))`.\\n    function eq(bytes32 a, bytes memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := and(eq(0x20, mload(b)), eq(a, mload(add(b, 0x20))))\\n        }\\n    }\\n\\n    /// @dev Returns `abi.decode(a, (bytes32)) == a`.\\n    function eq(bytes memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := and(eq(0x20, mload(a)), eq(b, mload(add(a, 0x20))))\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*               BYTE SLICE HASHING OPERATIONS                */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function hash(bytes memory b, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(b)\\n            end := xor(end, mul(xor(end, n), lt(n, end)))\\n            start := xor(start, mul(xor(start, n), lt(n, start)))\\n            result := keccak256(add(add(b, 0x20), start), mul(gt(end, start), sub(end, start)))\\n        }\\n    }\\n\\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\\n    function hash(bytes memory b, uint256 start) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(b)\\n            start := xor(start, mul(xor(start, n), lt(n, start)))\\n            result := keccak256(add(add(b, 0x20), start), mul(gt(n, start), sub(n, start)))\\n        }\\n    }\\n\\n    /// @dev Returns the keccak256 of the bytes.\\n    function hash(bytes memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := keccak256(add(b, 0x20), mload(b))\\n        }\\n    }\\n\\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function hashCalldata(bytes calldata b, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\\n            let n := mul(gt(end, start), sub(end, start))\\n            calldatacopy(mload(0x40), add(b.offset, start), n)\\n            result := keccak256(mload(0x40), n)\\n        }\\n    }\\n\\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\\n    function hashCalldata(bytes calldata b, uint256 start) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\\n            let n := mul(gt(b.length, start), sub(b.length, start))\\n            calldatacopy(mload(0x40), add(b.offset, start), n)\\n            result := keccak256(mload(0x40), n)\\n        }\\n    }\\n\\n    /// @dev Returns the keccak256 of the bytes.\\n    function hashCalldata(bytes calldata b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            calldatacopy(mload(0x40), b.offset, b.length)\\n            result := keccak256(mload(0x40), b.length)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      SHA2-256 HELPERS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns `sha256(abi.encode(b))`. Yes, it's more efficient.\\n    function sha2(bytes32 b) internal view returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, b)\\n            result := mload(staticcall(gas(), 2, 0x00, 0x20, 0x01, 0x20))\\n            if iszero(returndatasize()) { invalid() }\\n        }\\n    }\\n\\n    /// @dev Returns the sha256 of the slice from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function sha2(bytes memory b, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bytes32 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(b)\\n            end := xor(end, mul(xor(end, n), lt(n, end)))\\n            start := xor(start, mul(xor(start, n), lt(n, start)))\\n            // forgefmt: disable-next-item\\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\\n                mul(gt(end, start), sub(end, start)), 0x01, 0x20))\\n            if iszero(returndatasize()) { invalid() }\\n        }\\n    }\\n\\n    /// @dev Returns the sha256 of the slice from `start` to the end of the bytes.\\n    function sha2(bytes memory b, uint256 start) internal view returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(b)\\n            start := xor(start, mul(xor(start, n), lt(n, start)))\\n            // forgefmt: disable-next-item\\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\\n                mul(gt(n, start), sub(n, start)), 0x01, 0x20))\\n            if iszero(returndatasize()) { invalid() }\\n        }\\n    }\\n\\n    /// @dev Returns the sha256 of the bytes.\\n    function sha2(bytes memory b) internal view returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(staticcall(gas(), 2, add(b, 0x20), mload(b), 0x01, 0x20))\\n            if iszero(returndatasize()) { invalid() }\\n        }\\n    }\\n\\n    /// @dev Returns the sha256 of the slice from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function sha2Calldata(bytes calldata b, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bytes32 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\\n            let n := mul(gt(end, start), sub(end, start))\\n            calldatacopy(mload(0x40), add(b.offset, start), n)\\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\\n            if iszero(returndatasize()) { invalid() }\\n        }\\n    }\\n\\n    /// @dev Returns the sha256 of the slice from `start` to the end of the bytes.\\n    function sha2Calldata(bytes calldata b, uint256 start) internal view returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\\n            let n := mul(gt(b.length, start), sub(b.length, start))\\n            calldatacopy(mload(0x40), add(b.offset, start), n)\\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\\n            if iszero(returndatasize()) { invalid() }\\n        }\\n    }\\n\\n    /// @dev Returns the sha256 of the bytes.\\n    function sha2Calldata(bytes calldata b) internal view returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            calldatacopy(mload(0x40), b.offset, b.length)\\n            result := mload(staticcall(gas(), 2, mload(0x40), b.length, 0x01, 0x20))\\n            if iszero(returndatasize()) { invalid() }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1eae95036f571ec3e914f3221427692f33be0524aa88a7b1f3555acc28d5d486\",\"license\":\"MIT\"},\"solady/src/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Initializable mixin for the upgradeable contracts.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Initializable.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/proxy/utils/Initializable.sol)\\nabstract contract Initializable {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The contract is already initialized.\\n    error InvalidInitialization();\\n\\n    /// @dev The contract is not initializing.\\n    error NotInitializing();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Triggered when the contract has been initialized.\\n    event Initialized(uint64 version);\\n\\n    /// @dev `keccak256(bytes(\\\"Initialized(uint64)\\\"))`.\\n    bytes32 private constant _INTIALIZED_EVENT_SIGNATURE =\\n        0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The default initializable slot is given by:\\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\\\"_INITIALIZABLE_SLOT\\\")))))`.\\n    ///\\n    /// Bits Layout:\\n    /// - [0]     `initializing`\\n    /// - [1..64] `initializedVersion`\\n    bytes32 private constant _INITIALIZABLE_SLOT =\\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffbf601132;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CONSTRUCTOR                         */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    constructor() {\\n        // Construction time check to ensure that `_initializableSlot()` is not\\n        // overridden to zero. Will be optimized away if there is no revert.\\n        require(_initializableSlot() != bytes32(0));\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Override to return a non-zero custom storage slot if required.\\n    function _initializableSlot() internal pure virtual returns (bytes32) {\\n        return _INITIALIZABLE_SLOT;\\n    }\\n\\n    /// @dev Guards an initializer function so that it can be invoked at most once.\\n    ///\\n    /// You can guard a function with `onlyInitializing` such that it can be called\\n    /// through a function guarded with `initializer`.\\n    ///\\n    /// This is similar to `reinitializer(1)`, except that in the context of a constructor,\\n    /// an `initializer` guarded function can be invoked multiple times.\\n    /// This can be useful during testing and is not expected to be used in production.\\n    ///\\n    /// Emits an {Initialized} event.\\n    modifier initializer() virtual {\\n        bytes32 s = _initializableSlot();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let i := sload(s)\\n            // Set `initializing` to 1, `initializedVersion` to 1.\\n            sstore(s, 3)\\n            // If `!(initializing == 0 && initializedVersion == 0)`.\\n            if i {\\n                // If `!(address(this).code.length == 0 && initializedVersion == 1)`.\\n                if iszero(lt(extcodesize(address()), eq(shr(1, i), 1))) {\\n                    mstore(0x00, 0xf92ee8a9) // `InvalidInitialization()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                s := shl(shl(255, i), s) // Skip initializing if `initializing == 1`.\\n            }\\n        }\\n        _;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if s {\\n                // Set `initializing` to 0, `initializedVersion` to 1.\\n                sstore(s, 2)\\n                // Emit the {Initialized} event.\\n                mstore(0x20, 1)\\n                log1(0x20, 0x20, _INTIALIZED_EVENT_SIGNATURE)\\n            }\\n        }\\n    }\\n\\n    /// @dev Guards an reinitialzer function so that it can be invoked at most once.\\n    ///\\n    /// You can guard a function with `onlyInitializing` such that it can be called\\n    /// through a function guarded with `reinitializer`.\\n    ///\\n    /// Emits an {Initialized} event.\\n    modifier reinitializer(uint64 version) virtual {\\n        bytes32 s = _initializableSlot();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean upper bits, and shift left by 1 to make space for the initializing bit.\\n            version := shl(1, and(version, 0xffffffffffffffff))\\n            let i := sload(s)\\n            // If `initializing == 1 || initializedVersion >= version`.\\n            if iszero(lt(and(i, 1), lt(i, version))) {\\n                mstore(0x00, 0xf92ee8a9) // `InvalidInitialization()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set `initializing` to 1, `initializedVersion` to `version`.\\n            sstore(s, or(1, version))\\n        }\\n        _;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Set `initializing` to 0, `initializedVersion` to `version`.\\n            sstore(s, version)\\n            // Emit the {Initialized} event.\\n            mstore(0x20, shr(1, version))\\n            log1(0x20, 0x20, _INTIALIZED_EVENT_SIGNATURE)\\n        }\\n    }\\n\\n    /// @dev Guards a function such that it can only be called in the scope\\n    /// of a function guarded with `initializer` or `reinitializer`.\\n    modifier onlyInitializing() virtual {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /// @dev Reverts if the contract is not initializing.\\n    function _checkInitializing() internal view virtual {\\n        bytes32 s = _initializableSlot();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(and(1, sload(s))) {\\n                mstore(0x00, 0xd7e6bcf8) // `NotInitializing()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Locks any future initializations by setting the initialized version to `2**64 - 1`.\\n    ///\\n    /// Calling this in the constructor will prevent the contract from being initialized\\n    /// or reinitialized. It is recommended to use this to lock implementation contracts\\n    /// that are designed to be called through proxies.\\n    ///\\n    /// Emits an {Initialized} event the first time it is successfully called.\\n    function _disableInitializers() internal virtual {\\n        bytes32 s = _initializableSlot();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let i := sload(s)\\n            if and(i, 1) {\\n                mstore(0x00, 0xf92ee8a9) // `InvalidInitialization()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let uint64max := 0xffffffffffffffff\\n            if iszero(eq(shr(1, i), uint64max)) {\\n                // Set `initializing` to 0, `initializedVersion` to `2**64 - 1`.\\n                sstore(s, shl(1, uint64max))\\n                // Emit the {Initialized} event.\\n                mstore(0x20, uint64max)\\n                log1(0x20, 0x20, _INTIALIZED_EVENT_SIGNATURE)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the highest version that has been initialized.\\n    function _getInitializedVersion() internal view virtual returns (uint64 version) {\\n        bytes32 s = _initializableSlot();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            version := shr(1, sload(s))\\n        }\\n    }\\n\\n    /// @dev Returns whether the contract is currently initializing.\\n    function _isInitializing() internal view virtual returns (bool result) {\\n        bytes32 s = _initializableSlot();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := and(1, sload(s))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0873a4cd2510a6f741a3abe8bbb40e6969f45b667431e80247e14ca54f7eb644\",\"license\":\"MIT\"},\"solady/src/utils/LibBytes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for byte related operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBytes.sol)\\nlibrary LibBytes {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Goated bytes storage struct that totally MOGs, no cap, fr.\\n    /// Uses less gas and bytecode than Solidity's native bytes storage. It's meta af.\\n    /// Packs length with the first 31 bytes if <255 bytes, so it\\u2019s mad tight.\\n    struct BytesStorage {\\n        bytes32 _spacer;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the bytes.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  BYTE STORAGE OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Sets the value of the bytes storage `$` to `s`.\\n    function set(BytesStorage storage $, bytes memory s) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(s)\\n            let packed := or(0xff, shl(8, n))\\n            for { let i := 0 } 1 {} {\\n                if iszero(gt(n, 0xfe)) {\\n                    i := 0x1f\\n                    packed := or(n, shl(8, mload(add(s, i))))\\n                    if iszero(gt(n, i)) { break }\\n                }\\n                let o := add(s, 0x20)\\n                mstore(0x00, $.slot)\\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\\n                    sstore(add(p, shr(5, i)), mload(add(o, i)))\\n                    i := add(i, 0x20)\\n                    if iszero(lt(i, n)) { break }\\n                }\\n                break\\n            }\\n            sstore($.slot, packed)\\n        }\\n    }\\n\\n    /// @dev Sets the value of the bytes storage `$` to `s`.\\n    function setCalldata(BytesStorage storage $, bytes calldata s) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let packed := or(0xff, shl(8, s.length))\\n            for { let i := 0 } 1 {} {\\n                if iszero(gt(s.length, 0xfe)) {\\n                    i := 0x1f\\n                    packed := or(s.length, shl(8, shr(8, calldataload(s.offset))))\\n                    if iszero(gt(s.length, i)) { break }\\n                }\\n                mstore(0x00, $.slot)\\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\\n                    sstore(add(p, shr(5, i)), calldataload(add(s.offset, i)))\\n                    i := add(i, 0x20)\\n                    if iszero(lt(i, s.length)) { break }\\n                }\\n                break\\n            }\\n            sstore($.slot, packed)\\n        }\\n    }\\n\\n    /// @dev Sets the value of the bytes storage `$` to the empty bytes.\\n    function clear(BytesStorage storage $) internal {\\n        delete $._spacer;\\n    }\\n\\n    /// @dev Returns whether the value stored is `$` is the empty bytes \\\"\\\".\\n    function isEmpty(BytesStorage storage $) internal view returns (bool) {\\n        return uint256($._spacer) & 0xff == uint256(0);\\n    }\\n\\n    /// @dev Returns the length of the value stored in `$`.\\n    function length(BytesStorage storage $) internal view returns (uint256 result) {\\n        result = uint256($._spacer);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := and(0xff, result)\\n            result := or(mul(shr(8, result), eq(0xff, n)), mul(n, iszero(eq(0xff, n))))\\n        }\\n    }\\n\\n    /// @dev Returns the value stored in `$`.\\n    function get(BytesStorage storage $) internal view returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let o := add(result, 0x20)\\n            let packed := sload($.slot)\\n            let n := shr(8, packed)\\n            for { let i := 0 } 1 {} {\\n                if iszero(eq(or(packed, 0xff), packed)) {\\n                    mstore(o, packed)\\n                    n := and(0xff, packed)\\n                    i := 0x1f\\n                    if iszero(gt(n, i)) { break }\\n                }\\n                mstore(0x00, $.slot)\\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\\n                    mstore(add(o, i), sload(add(p, shr(5, i))))\\n                    i := add(i, 0x20)\\n                    if iszero(lt(i, n)) { break }\\n                }\\n                break\\n            }\\n            mstore(result, n) // Store the length of the memory.\\n            mstore(add(o, n), 0) // Zeroize the slot after the bytes.\\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      BYTES OPERATIONS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.\\n    function replace(bytes memory subject, bytes memory needle, bytes memory replacement)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let needleLen := mload(needle)\\n            let replacementLen := mload(replacement)\\n            let d := sub(result, subject) // Memory difference.\\n            let i := add(subject, 0x20) // Subject bytes pointer.\\n            mstore(0x00, add(i, mload(subject))) // End of subject.\\n            if iszero(gt(needleLen, mload(subject))) {\\n                let subjectSearchEnd := add(sub(mload(0x00), needleLen), 1)\\n                let h := 0 // The hash of `needle`.\\n                if iszero(lt(needleLen, 0x20)) { h := keccak256(add(needle, 0x20), needleLen) }\\n                let s := mload(add(needle, 0x20))\\n                for { let m := shl(3, sub(0x20, and(needleLen, 0x1f))) } 1 {} {\\n                    let t := mload(i)\\n                    // Whether the first `needleLen % 32` bytes of `subject` and `needle` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(i, needleLen), h)) {\\n                                mstore(add(i, d), t)\\n                                i := add(i, 1)\\n                                if iszero(lt(i, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let j := 0 } 1 {} {\\n                            mstore(add(add(i, d), j), mload(add(add(replacement, 0x20), j)))\\n                            j := add(j, 0x20)\\n                            if iszero(lt(j, replacementLen)) { break }\\n                        }\\n                        d := sub(add(d, replacementLen), needleLen)\\n                        if needleLen {\\n                            i := add(i, needleLen)\\n                            if iszero(lt(i, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(add(i, d), t)\\n                    i := add(i, 1)\\n                    if iszero(lt(i, subjectSearchEnd)) { break }\\n                }\\n            }\\n            let end := mload(0x00)\\n            let n := add(sub(d, add(result, 0x20)), end)\\n            // Copy the rest of the bytes one word at a time.\\n            for {} lt(i, end) { i := add(i, 0x20) } { mstore(add(i, d), mload(i)) }\\n            let o := add(i, d)\\n            mstore(o, 0) // Zeroize the slot after the bytes.\\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\\n            mstore(result, n) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\\n    /// needleing from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\\n    function indexOf(bytes memory subject, bytes memory needle, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := not(0) // Initialize to `NOT_FOUND`.\\n            for { let subjectLen := mload(subject) } 1 {} {\\n                if iszero(mload(needle)) {\\n                    result := from\\n                    if iszero(gt(from, subjectLen)) { break }\\n                    result := subjectLen\\n                    break\\n                }\\n                let needleLen := mload(needle)\\n                let subjectStart := add(subject, 0x20)\\n\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLen), needleLen), 1)\\n                let m := shl(3, sub(0x20, and(needleLen, 0x1f)))\\n                let s := mload(add(needle, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLen))) { break }\\n\\n                if iszero(lt(needleLen, 0x20)) {\\n                    for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, needleLen), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\\n    /// needleing from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\\n    function indexOf(bytes memory subject, bytes memory needle) internal pure returns (uint256) {\\n        return indexOf(subject, needle, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\\n    /// needleing from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\\n    function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let needleLen := mload(needle)\\n                if gt(needleLen, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), needleLen)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\\n                    if eq(keccak256(subject, needleLen), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\\n    /// needleing from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\\n    function lastIndexOf(bytes memory subject, bytes memory needle)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return lastIndexOf(subject, needle, type(uint256).max);\\n    }\\n\\n    /// @dev Returns true if `needle` is found in `subject`, false otherwise.\\n    function contains(bytes memory subject, bytes memory needle) internal pure returns (bool) {\\n        return indexOf(subject, needle) != NOT_FOUND;\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `needle`.\\n    function startsWith(bytes memory subject, bytes memory needle)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(needle)\\n            // Just using keccak256 directly is actually cheaper.\\n            let t := eq(keccak256(add(subject, 0x20), n), keccak256(add(needle, 0x20), n))\\n            result := lt(gt(n, mload(subject)), t)\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `needle`.\\n    function endsWith(bytes memory subject, bytes memory needle)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(needle)\\n            let notInRange := gt(n, mload(subject))\\n            // `subject + 0x20 + max(subject.length - needle.length, 0)`.\\n            let t := add(add(subject, 0x20), mul(iszero(notInRange), sub(mload(subject), n)))\\n            // Just using keccak256 directly is actually cheaper.\\n            result := gt(eq(keccak256(t, n), keccak256(add(needle, 0x20), n)), notInRange)\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(bytes memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let l := mload(subject) // Subject length.\\n            if iszero(or(iszero(times), iszero(l))) {\\n                result := mload(0x40)\\n                subject := add(subject, 0x20)\\n                let o := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let j := 0 } 1 {} {\\n                        mstore(add(o, j), mload(add(subject, j)))\\n                        j := add(j, 0x20)\\n                        if iszero(lt(j, l)) { break }\\n                    }\\n                    o := add(o, l)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(o, 0) // Zeroize the slot after the bytes.\\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(bytes memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let l := mload(subject) // Subject length.\\n            if iszero(gt(l, end)) { end := l }\\n            if iszero(gt(l, start)) { start := l }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let n := sub(end, start)\\n                let i := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let j := and(add(n, 0x1f), w) } 1 {} {\\n                    mstore(add(result, j), mload(add(i, j)))\\n                    j := add(j, w) // `sub(j, 0x20)`.\\n                    if iszero(j) { break }\\n                }\\n                let o := add(add(result, 0x20), n)\\n                mstore(o, 0) // Zeroize the slot after the bytes.\\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\\n                mstore(result, n) // Store the length.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\\n    /// `start` is a byte offset.\\n    function slice(bytes memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        result = slice(subject, start, type(uint256).max);\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets. Faster than Solidity's native slicing.\\n    function sliceCalldata(bytes calldata subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (bytes calldata result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            end := xor(end, mul(xor(end, subject.length), lt(subject.length, end)))\\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\\n            result.offset := add(subject.offset, start)\\n            result.length := mul(lt(start, end), sub(end, start))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\\n    /// `start` is a byte offset. Faster than Solidity's native slicing.\\n    function sliceCalldata(bytes calldata subject, uint256 start)\\n        internal\\n        pure\\n        returns (bytes calldata result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\\n            result.offset := add(subject.offset, start)\\n            result.length := mul(lt(start, subject.length), sub(subject.length, start))\\n        }\\n    }\\n\\n    /// @dev Reduces the size of `subject` to `n`.\\n    /// If `n` is greater than the size of `subject`, this will be a no-op.\\n    function truncate(bytes memory subject, uint256 n)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := subject\\n            mstore(mul(lt(n, mload(result)), result), n)\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject`, with the length reduced to `n`.\\n    /// If `n` is greater than the size of `subject`, this will be a no-op.\\n    function truncatedCalldata(bytes calldata subject, uint256 n)\\n        internal\\n        pure\\n        returns (bytes calldata result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result.offset := subject.offset\\n            result.length := xor(n, mul(xor(n, subject.length), lt(subject.length, n)))\\n        }\\n    }\\n\\n    /// @dev Returns all the indices of `needle` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(bytes memory subject, bytes memory needle)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLen := mload(needle)\\n            if iszero(gt(searchLen, mload(subject))) {\\n                result := mload(0x40)\\n                let i := add(subject, 0x20)\\n                let o := add(result, 0x20)\\n                let subjectSearchEnd := add(sub(add(i, mload(subject)), searchLen), 1)\\n                let h := 0 // The hash of `needle`.\\n                if iszero(lt(searchLen, 0x20)) { h := keccak256(add(needle, 0x20), searchLen) }\\n                let s := mload(add(needle, 0x20))\\n                for { let m := shl(3, sub(0x20, and(searchLen, 0x1f))) } 1 {} {\\n                    let t := mload(i)\\n                    // Whether the first `searchLen % 32` bytes of `subject` and `needle` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(i, searchLen), h)) {\\n                                i := add(i, 1)\\n                                if iszero(lt(i, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        mstore(o, sub(i, add(subject, 0x20))) // Append to `result`.\\n                        o := add(o, 0x20)\\n                        i := add(i, searchLen) // Advance `i` by `searchLen`.\\n                        if searchLen {\\n                            if iszero(lt(i, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    i := add(i, 1)\\n                    if iszero(lt(i, subjectSearchEnd)) { break }\\n                }\\n                mstore(result, shr(5, sub(o, add(result, 0x20)))) // Store the length of `result`.\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(o, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of bytess based on the `delimiter` inside of the `subject` bytes.\\n    function split(bytes memory subject, bytes memory delimiter)\\n        internal\\n        pure\\n        returns (bytes[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            for { let prevIndex := 0 } 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let l := sub(index, prevIndex)\\n                    mstore(element, l) // Store the length of the element.\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(l, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    mstore(add(add(element, 0x20), l), 0) // Zeroize the slot after the bytes.\\n                    // Allocate memory for the length and the bytes, rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(l, 0x3f), w)))\\n                    mstore(indexPtr, element) // Store the `element` into the array.\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated bytes of `a` and `b`.\\n    /// Cheaper than `bytes.concat()` and does not de-align the free memory pointer.\\n    function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let w := not(0x1f)\\n            let aLen := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLen, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLen := mload(b)\\n            let output := add(result, aLen)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLen, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLen := add(aLen, bLen)\\n            let last := add(add(result, 0x20), totalLen)\\n            mstore(last, 0) // Zeroize the slot after the bytes.\\n            mstore(result, totalLen) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(bytes memory a, bytes memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small bytes.\\n    function eqs(bytes memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\\n            let x := not(or(m, or(b, add(m, and(b, m)))))\\n            let r := shl(7, iszero(iszero(shr(128, x))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Returns 0 if `a == b`, -1 if `a < b`, +1 if `a > b`.\\n    /// If `a` == b[:a.length]`, and `a.length < b.length`, returns -1.\\n    function cmp(bytes memory a, bytes memory b) internal pure returns (int256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLen := mload(a)\\n            let bLen := mload(b)\\n            let n := and(xor(aLen, mul(xor(aLen, bLen), lt(bLen, aLen))), not(0x1f))\\n            if n {\\n                for { let i := 0x20 } 1 {} {\\n                    let x := mload(add(a, i))\\n                    let y := mload(add(b, i))\\n                    if iszero(or(xor(x, y), eq(i, n))) {\\n                        i := add(i, 0x20)\\n                        continue\\n                    }\\n                    result := sub(gt(x, y), lt(x, y))\\n                    break\\n                }\\n            }\\n            // forgefmt: disable-next-item\\n            if iszero(result) {\\n                let l := 0x201f1e1d1c1b1a191817161514131211100f0e0d0c0b0a090807060504030201\\n                let x := and(mload(add(add(a, 0x20), n)), shl(shl(3, byte(sub(aLen, n), l)), not(0)))\\n                let y := and(mload(add(add(b, 0x20), n)), shl(shl(3, byte(sub(bLen, n), l)), not(0)))\\n                result := sub(gt(x, y), lt(x, y))\\n                if iszero(result) { result := sub(gt(aLen, bLen), lt(aLen, bLen)) }\\n            }\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(bytes memory a) internal pure {\\n        assembly {\\n            // Assumes that the bytes does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retUnpaddedSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the bytes is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retUnpaddedSize), 0)\\n            mstore(retStart, 0x20) // Store the return offset.\\n            // End the transaction, returning the bytes.\\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` with minimal copying.\\n    function directReturn(bytes[] memory a) internal pure {\\n        assembly {\\n            let n := mload(a) // `a.length`.\\n            let o := add(a, 0x20) // Start of elements in `a`.\\n            let u := a // Highest memory slot.\\n            let w := not(0x1f)\\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\\n                let c := add(o, shl(5, i)) // Location of pointer to `a[i]`.\\n                let s := mload(c) // `a[i]`.\\n                let l := mload(s) // `a[i].length`.\\n                let r := and(l, 0x1f) // `a[i].length % 32`.\\n                let z := add(0x20, and(l, w)) // Offset of last word in `a[i]` from `s`.\\n                // If `s` comes before `o`, or `s` is not zero right padded.\\n                if iszero(lt(lt(s, o), or(iszero(r), iszero(shl(shl(3, r), mload(add(s, z))))))) {\\n                    let m := mload(0x40)\\n                    mstore(m, l) // Copy `a[i].length`.\\n                    for {} 1 {} {\\n                        mstore(add(m, z), mload(add(s, z))) // Copy `a[i]`, backwards.\\n                        z := add(z, w) // `sub(z, 0x20)`.\\n                        if iszero(z) { break }\\n                    }\\n                    let e := add(add(m, 0x20), l)\\n                    mstore(e, 0) // Zeroize the slot after the copied bytes.\\n                    mstore(0x40, add(e, 0x20)) // Allocate memory.\\n                    s := m\\n                }\\n                mstore(c, sub(s, o)) // Convert to calldata offset.\\n                let t := add(l, add(s, 0x20))\\n                if iszero(lt(t, u)) { u := t }\\n            }\\n            let retStart := add(a, w) // Assumes `a` doesn't start from scratch space.\\n            mstore(retStart, 0x20) // Store the return offset.\\n            return(retStart, add(0x40, sub(u, retStart))) // End the transaction.\\n        }\\n    }\\n\\n    /// @dev Returns the word at `offset`, without any bounds checks.\\n    /// To load an address, you can use `address(bytes20(load(a, offset)))`.\\n    function load(bytes memory a, uint256 offset) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(add(add(a, 0x20), offset))\\n        }\\n    }\\n\\n    /// @dev Returns the word at `offset`, without any bounds checks.\\n    /// To load an address, you can use `address(bytes20(loadCalldata(a, offset)))`.\\n    function loadCalldata(bytes calldata a, uint256 offset)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := calldataload(add(a.offset, offset))\\n        }\\n    }\\n\\n    /// @dev Returns empty calldata bytes. For silencing the compiler.\\n    function emptyCalldata() internal pure returns (bytes calldata result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result.length := 0\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0ce2f2607e6408787d6f66d73f1b6d5726a96403f66e5c4edfc6d8451f96537c\",\"license\":\"MIT\"},\"solady/src/utils/LibString.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibBytes} from \\\"./LibBytes.sol\\\";\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n///\\n/// @dev Note:\\n/// For performance and bytecode compactness, most of the string operations are restricted to\\n/// byte strings (7-bit ASCII), except where otherwise specified.\\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\\n/// can lead to undefined behavior.\\nlibrary LibString {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Goated string storage struct that totally MOGs, no cap, fr.\\n    /// Uses less gas and bytecode than Solidity's native string storage. It's meta af.\\n    /// Packs length with the first 31 bytes if <255 bytes, so it\\u2019s mad tight.\\n    struct StringStorage {\\n        bytes32 _spacer;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The length of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /// @dev The length of the string is more than 32 bytes.\\n    error TooBigForSmallString();\\n\\n    /// @dev The input string must be a 7-bit ASCII.\\n    error StringNot7BitASCII();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\\n    uint128 internal constant ALPHANUMERIC_7_BIT_ASCII = 0x7fffffe07fffffe03ff000000000000;\\n\\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\\n    uint128 internal constant LETTERS_7_BIT_ASCII = 0x7fffffe07fffffe0000000000000000;\\n\\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyz'.\\n    uint128 internal constant LOWERCASE_7_BIT_ASCII = 0x7fffffe000000000000000000000000;\\n\\n    /// @dev Lookup for 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\\n    uint128 internal constant UPPERCASE_7_BIT_ASCII = 0x7fffffe0000000000000000;\\n\\n    /// @dev Lookup for '0123456789'.\\n    uint128 internal constant DIGITS_7_BIT_ASCII = 0x3ff000000000000;\\n\\n    /// @dev Lookup for '0123456789abcdefABCDEF'.\\n    uint128 internal constant HEXDIGITS_7_BIT_ASCII = 0x7e0000007e03ff000000000000;\\n\\n    /// @dev Lookup for '01234567'.\\n    uint128 internal constant OCTDIGITS_7_BIT_ASCII = 0xff000000000000;\\n\\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%&\\\\'()*+,-./:;<=>?@[\\\\\\\\]^_`{|}~ \\\\t\\\\n\\\\r\\\\x0b\\\\x0c'.\\n    uint128 internal constant PRINTABLE_7_BIT_ASCII = 0x7fffffffffffffffffffffff00003e00;\\n\\n    /// @dev Lookup for '!\\\"#$%&\\\\'()*+,-./:;<=>?@[\\\\\\\\]^_`{|}~'.\\n    uint128 internal constant PUNCTUATION_7_BIT_ASCII = 0x78000001f8000001fc00fffe00000000;\\n\\n    /// @dev Lookup for ' \\\\t\\\\n\\\\r\\\\x0b\\\\x0c'.\\n    uint128 internal constant WHITESPACE_7_BIT_ASCII = 0x100003e00;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                 STRING STORAGE OPERATIONS                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Sets the value of the string storage `$` to `s`.\\n    function set(StringStorage storage $, string memory s) internal {\\n        LibBytes.set(bytesStorage($), bytes(s));\\n    }\\n\\n    /// @dev Sets the value of the string storage `$` to `s`.\\n    function setCalldata(StringStorage storage $, string calldata s) internal {\\n        LibBytes.setCalldata(bytesStorage($), bytes(s));\\n    }\\n\\n    /// @dev Sets the value of the string storage `$` to the empty string.\\n    function clear(StringStorage storage $) internal {\\n        delete $._spacer;\\n    }\\n\\n    /// @dev Returns whether the value stored is `$` is the empty string \\\"\\\".\\n    function isEmpty(StringStorage storage $) internal view returns (bool) {\\n        return uint256($._spacer) & 0xff == uint256(0);\\n    }\\n\\n    /// @dev Returns the length of the value stored in `$`.\\n    function length(StringStorage storage $) internal view returns (uint256) {\\n        return LibBytes.length(bytesStorage($));\\n    }\\n\\n    /// @dev Returns the value stored in `$`.\\n    function get(StringStorage storage $) internal view returns (string memory) {\\n        return string(LibBytes.get(bytesStorage($)));\\n    }\\n\\n    /// @dev Helper to cast `$` to a `BytesStorage`.\\n    function bytesStorage(StringStorage storage $)\\n        internal\\n        pure\\n        returns (LibBytes.BytesStorage storage casted)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            casted.slot := $.slot\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            result := add(mload(0x40), 0x80)\\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\\n            mstore(result, 0) // Zeroize the slot after the string.\\n\\n            let end := result // Cache the end of the memory to calculate the length later.\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                result := add(result, w) // `sub(result, 1)`.\\n                // Store the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(result, add(48, mod(temp, 10)))\\n                temp := div(temp, 10) // Keep dividing `temp` until zero.\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(end, result)\\n            result := sub(result, 0x20) // Move the pointer 32 bytes back to make room for the length.\\n            mstore(result, n) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory result) {\\n        if (value >= 0) return toString(uint256(value));\\n        unchecked {\\n            result = toString(~uint256(value) + 1);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let n := mload(result) // Load the string length.\\n            mstore(result, 0x2d) // Store the '-' character.\\n            result := sub(result, 1) // Move back the string pointer by a byte.\\n            mstore(result, add(n, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `byteCount` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `byteCount * 2 + 2` bytes.\\n    /// Reverts if `byteCount` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 byteCount)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = toHexStringNoPrefix(value, byteCount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := add(mload(result), 2) // Compute the length.\\n            mstore(result, 0x3078) // Store the \\\"0x\\\" prefix.\\n            result := sub(result, 2) // Move the pointer.\\n            mstore(result, n) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `byteCount` bytes.\\n    /// The output is not prefixed with \\\"0x\\\" and is encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `byteCount * 2` bytes.\\n    /// Reverts if `byteCount` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 byteCount)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `byteCount * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            result := add(mload(0x40), and(add(shl(1, byteCount), 0x42), not(0x1f)))\\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\\n            mstore(result, 0) // Zeroize the slot after the string.\\n\\n            let end := result // Cache the end to calculate the length later.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(result, add(byteCount, byteCount))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                result := add(result, w) // `sub(result, 2)`.\\n                mstore8(add(result, 1), mload(and(temp, 15)))\\n                mstore8(result, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(result, start)) { break }\\n            }\\n            if temp {\\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let n := sub(end, result)\\n            result := sub(result, 0x20)\\n            mstore(result, n) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory result) {\\n        result = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := add(mload(result), 2) // Compute the length.\\n            mstore(result, 0x3078) // Store the \\\"0x\\\" prefix.\\n            result := sub(result, 2) // Move the pointer.\\n            mstore(result, n) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory result) {\\n        result = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\\n            let n := add(mload(result), 2) // Compute the length.\\n            mstore(add(result, o), 0x3078) // Store the \\\"0x\\\" prefix, accounting for leading zero.\\n            result := sub(add(result, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\\n            let n := mload(result) // Get the length.\\n            result := add(result, o) // Move the pointer, accounting for leading zero.\\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            result := add(mload(0x40), 0x80)\\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\\n            mstore(result, 0) // Zeroize the slot after the string.\\n\\n            let end := result // Cache the end to calculate the length later.\\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \\\"0123456789abcdef\\\" lookup.\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                result := add(result, w) // `sub(result, 2)`.\\n                mstore8(add(result, 1), mload(and(temp, 15)))\\n                mstore8(result, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(end, result)\\n            result := sub(result, 0x20)\\n            mstore(result, n) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory result) {\\n        result = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(result, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory result) {\\n        result = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := add(mload(result), 2) // Compute the length.\\n            mstore(result, 0x3078) // Store the \\\"0x\\\" prefix.\\n            result := sub(result, 2) // Move the pointer.\\n            mstore(result, n) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            // Allocate memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(result, 0x80))\\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \\\"0123456789abcdef\\\" lookup.\\n\\n            result := add(result, 2)\\n            mstore(result, 40) // Store the length.\\n            let o := add(result, 0x20)\\n            mstore(add(o, 40), 0) // Zeroize the slot after the string.\\n            value := shl(96, value)\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory result) {\\n        result = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := add(mload(result), 2) // Compute the length.\\n            mstore(result, 0x3078) // Store the \\\"0x\\\" prefix.\\n            result := sub(result, 2) // Move the pointer.\\n            mstore(result, n) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(raw)\\n            result := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(result, add(n, n)) // Store the length of the output.\\n\\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \\\"0123456789abcdef\\\" lookup.\\n            let o := add(result, 0x20)\\n            let end := add(raw, n)\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let mask := shl(7, div(not(0), 255))\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string,\\n    /// AND all characters are in the `allowed` lookup.\\n    /// Note: If `s` is empty, returns true regardless of `allowed`.\\n    function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            if mload(s) {\\n                let allowed_ := shr(128, shl(128, allowed))\\n                let o := add(s, 0x20)\\n                for { let end := add(o, mload(s)) } 1 {} {\\n                    result := and(result, shr(byte(0, mload(o)), allowed_))\\n                    o := add(o, 1)\\n                    if iszero(and(result, lt(o, end))) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Converts the bytes in the 7-bit ASCII string `s` to\\n    /// an allowed lookup for use in `is7BitASCII(s, allowed)`.\\n    /// To save runtime gas, you can cache the result in an immutable variable.\\n    function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                let o := add(s, 0x20)\\n                for { let end := add(o, mload(s)) } 1 {} {\\n                    result := or(result, shl(byte(0, mload(o)), 1))\\n                    o := add(o, 1)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                if shr(128, result) {\\n                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // For performance and bytecode compactness, byte string operations are restricted\\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\\n    // can lead to undefined behavior.\\n\\n    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.\\n    function replace(string memory subject, string memory needle, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(LibBytes.replace(bytes(subject), bytes(needle), bytes(replacement)));\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\\n    /// needleing from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\\n    function indexOf(string memory subject, string memory needle, uint256 from)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBytes.indexOf(bytes(subject), bytes(needle), from);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\\n    /// needleing from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\\n    function indexOf(string memory subject, string memory needle) internal pure returns (uint256) {\\n        return LibBytes.indexOf(bytes(subject), bytes(needle), 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\\n    /// needleing from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\\n    function lastIndexOf(string memory subject, string memory needle, uint256 from)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), from);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\\n    /// needleing from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\\n    function lastIndexOf(string memory subject, string memory needle)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), type(uint256).max);\\n    }\\n\\n    /// @dev Returns true if `needle` is found in `subject`, false otherwise.\\n    function contains(string memory subject, string memory needle) internal pure returns (bool) {\\n        return LibBytes.contains(bytes(subject), bytes(needle));\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `needle`.\\n    function startsWith(string memory subject, string memory needle) internal pure returns (bool) {\\n        return LibBytes.startsWith(bytes(subject), bytes(needle));\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `needle`.\\n    function endsWith(string memory subject, string memory needle) internal pure returns (bool) {\\n        return LibBytes.endsWith(bytes(subject), bytes(needle));\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times) internal pure returns (string memory) {\\n        return string(LibBytes.repeat(bytes(subject), times));\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(LibBytes.slice(bytes(subject), start, end));\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start) internal pure returns (string memory) {\\n        return string(LibBytes.slice(bytes(subject), start, type(uint256).max));\\n    }\\n\\n    /// @dev Returns all the indices of `needle` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory needle)\\n        internal\\n        pure\\n        returns (uint256[] memory)\\n    {\\n        return LibBytes.indicesOf(bytes(subject), bytes(needle));\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        bytes[] memory a = LibBytes.split(bytes(subject), bytes(delimiter));\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := a\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b) internal pure returns (string memory) {\\n        return string(LibBytes.concat(bytes(a), bytes(b)));\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(subject)\\n            if n {\\n                result := mload(0x40)\\n                let o := add(result, 0x20)\\n                let d := sub(subject, result)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                for { let end := add(o, n) } 1 {} {\\n                    let b := byte(0, mload(add(d, o)))\\n                    mstore8(o, xor(and(shr(b, flags), 0x20), b))\\n                    o := add(o, 1)\\n                    if eq(o, end) { break }\\n                }\\n                mstore(result, n) // Store the length.\\n                mstore(o, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    /// `s` must be null-terminated, or behavior will be undefined.\\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n := 0\\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\\\0'.\\n            mstore(result, n) // Store the length.\\n            let o := add(result, 0x20)\\n            mstore(o, s) // Store the bytes of the string.\\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(result, 0x40)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\\\0'.\\n            mstore(0x00, s)\\n            mstore(result, 0x00)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the string as a normalized null-terminated small string.\\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(s)\\n            if iszero(lt(result, 33)) {\\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let end := add(s, mload(s))\\n            let o := add(result, 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(o, c)\\n                    o := add(o, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(o, mload(and(t, 0x1f)))\\n                o := add(o, shr(5, t))\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let o := add(result, 0x20)\\n            if addDoubleQuotes {\\n                mstore8(o, 34)\\n                o := add(1, o)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(o, c)\\n                        o := add(o, 1)\\n                        continue\\n                    }\\n                    mstore8(o, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(o, 1), c)\\n                    o := add(o, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(o, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    o := add(o, 6)\\n                    continue\\n                }\\n                mstore8(o, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(o, 1), mload(add(c, 8)))\\n                o := add(o, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(o, 34)\\n                o := add(1, o)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Encodes `s` so that it can be safely used in a URI,\\n    /// just like `encodeURIComponent` in JavaScript.\\n    /// See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\\n    /// See: https://datatracker.ietf.org/doc/html/rfc2396\\n    /// See: https://datatracker.ietf.org/doc/html/rfc3986\\n    function encodeURIComponent(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            // Store \\\"0123456789ABCDEF\\\" in scratch space.\\n            // Uppercased to be consistent with JavaScript's implementation.\\n            mstore(0x0f, 0x30313233343536373839414243444546)\\n            let o := add(result, 0x20)\\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // If not in `[0-9A-Z-a-z-_.!~*'()]`.\\n                if iszero(and(1, shr(c, 0x47fffffe87fffffe03ff678200000000))) {\\n                    mstore8(o, 0x25) // '%'.\\n                    mstore8(add(o, 1), mload(and(shr(4, c), 15)))\\n                    mstore8(add(o, 2), mload(and(c, 15)))\\n                    o := add(o, 3)\\n                    continue\\n                }\\n                mstore8(o, c)\\n                o := add(o, 1)\\n            }\\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\\n            let x := not(or(m, or(b, add(m, and(b, m)))))\\n            let r := shl(7, iszero(iszero(shr(128, x))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Returns 0 if `a == b`, -1 if `a < b`, +1 if `a > b`.\\n    /// If `a` == b[:a.length]`, and `a.length < b.length`, returns -1.\\n    function cmp(string memory a, string memory b) internal pure returns (int256) {\\n        return LibBytes.cmp(bytes(a), bytes(b));\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40) // Grab the free memory pointer.\\n            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(result, 0) // Zeroize the length slot.\\n            mstore(add(result, 0x1f), packed) // Store the length and bytes.\\n            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLen := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    or( // Load the length and the bytes of `a` and `b`.\\n                    shl(shl(3, sub(0x1f, aLen)), mload(add(a, aLen))), mload(sub(add(b, 0x1e), aLen))),\\n                    // `totalLen != 0 && totalLen < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLen, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            resultA := mload(0x40) // Grab the free memory pointer.\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retUnpaddedSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retUnpaddedSize), 0)\\n            mstore(retStart, 0x20) // Store the return offset.\\n            // End the transaction, returning the string.\\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6c922f48e2ecc1c8fd6581b3a1c16d24ca0f30e816e9a73d4e6a194b4df03e48\",\"license\":\"MIT\"},\"solady/src/utils/P256.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized P256 wrapper.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/P256.sol)\\n/// @author Modified from Daimo P256 Verifier (https://github.com/daimo-eth/p256-verifier/blob/master/src/P256.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/P256.sol)\\nlibrary P256 {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Unable to verify the P256 signature, due to missing\\n    /// RIP-7212 P256 verifier precompile and missing Solidity P256 verifier.\\n    error P256VerificationFailed();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Address of the Solidity P256 verifier.\\n    /// Please make sure the contract is deployed onto the chain you are working on.\\n    /// See: https://gist.github.com/Vectorized/599b0d8a94d21bc74700eb1354e2f55c\\n    /// Unlike RIP-7212, this verifier returns `uint256(0)` on failure, to\\n    /// facilitate easier existence check. This verifier will also never revert.\\n    address internal constant VERIFIER = 0x000000000000D01eA45F9eFD5c54f037Fa57Ea1a;\\n\\n    /// @dev Address of the RIP-7212 P256 verifier precompile.\\n    /// Currently, we don't support EIP-7212's precompile at 0x0b as it has not been finalized.\\n    /// See: https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7212.md\\n    address internal constant RIP_PRECOMPILE = 0x0000000000000000000000000000000000000100;\\n\\n    /// @dev The order of the secp256r1 elliptic curve.\\n    uint256 internal constant N = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\\n\\n    /// @dev `N/2`. Used for checking the malleability of the signature.\\n    uint256 private constant _HALF_N =\\n        0x7fffffff800000007fffffffffffffffde737d56d38bcf4279dce5617e3192a8;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                P256 VERIFICATION OPERATIONS                */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns if the signature (`r`, `s`) is valid for `hash` and public key (`x`, `y`).\\n    /// Does NOT include the malleability check.\\n    function verifySignatureAllowMalleability(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 s,\\n        bytes32 x,\\n        bytes32 y\\n    ) internal view returns (bool isValid) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, hash)\\n            mstore(add(m, 0x20), r)\\n            mstore(add(m, 0x40), s)\\n            mstore(add(m, 0x60), x)\\n            mstore(add(m, 0x80), y)\\n            mstore(0x00, 0) // Zeroize the return slot before the staticcalls.\\n            pop(staticcall(gas(), RIP_PRECOMPILE, m, 0xa0, 0x00, 0x20))\\n            // RIP-7212 dictates that success returns `uint256(1)`.\\n            // But failure returns zero returndata, which is ambiguous.\\n            if iszero(returndatasize()) {\\n                pop(staticcall(gas(), VERIFIER, m, 0xa0, returndatasize(), 0x20))\\n                // Unlike RIP-7212, the verifier returns `uint256(0)` on failure,\\n                // allowing us to use the returndatasize to determine existence.\\n                if iszero(returndatasize()) {\\n                    mstore(returndatasize(), 0xd0d5039b) // `P256VerificationFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            isValid := eq(1, mload(0x00))\\n        }\\n    }\\n\\n    /// @dev Returns if the signature (`r`, `s`) is valid for `hash` and public key (`x`, `y`).\\n    /// Includes the malleability check.\\n    function verifySignature(bytes32 hash, bytes32 r, bytes32 s, bytes32 x, bytes32 y)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, hash)\\n            mstore(add(m, 0x20), r)\\n            mstore(add(m, 0x40), s)\\n            mstore(add(m, 0x60), x)\\n            mstore(add(m, 0x80), y)\\n            mstore(0x00, 0) // Zeroize the return slot before the staticcalls.\\n            pop(staticcall(gas(), RIP_PRECOMPILE, m, 0xa0, 0x00, 0x20))\\n            // RIP-7212 dictates that success returns `uint256(1)`.\\n            // But failure returns zero returndata, which is ambiguous.\\n            if iszero(returndatasize()) {\\n                pop(staticcall(gas(), VERIFIER, m, 0xa0, returndatasize(), 0x20))\\n                // Unlike RIP-7212, the verifier returns `uint256(0)` on failure,\\n                // allowing us to use the returndatasize to determine existence.\\n                if iszero(returndatasize()) {\\n                    mstore(returndatasize(), 0xd0d5039b) // `P256VerificationFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            // Optimize for happy path. Users are unlikely to pass in malleable signatures.\\n            isValid := lt(gt(s, _HALF_N), eq(1, mload(0x00)))\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      OTHER OPERATIONS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Helper function for `abi.decode(encoded, (bytes32, bytes32))`.\\n    /// If `encoded.length < 64`, `(x, y)` will be `(0, 0)`, which is an invalid point.\\n    function tryDecodePoint(bytes memory encoded) internal pure returns (bytes32 x, bytes32 y) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let t := gt(mload(encoded), 0x3f)\\n            x := mul(mload(add(encoded, 0x20)), t)\\n            y := mul(mload(add(encoded, 0x40)), t)\\n        }\\n    }\\n\\n    /// @dev Helper function for `abi.decode(encoded, (bytes32, bytes32))`.\\n    /// If `encoded.length < 64`, `(x, y)` will be `(0, 0)`, which is an invalid point.\\n    function tryDecodePointCalldata(bytes calldata encoded)\\n        internal\\n        pure\\n        returns (bytes32 x, bytes32 y)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let t := gt(encoded.length, 0x3f)\\n            x := mul(calldataload(encoded.offset), t)\\n            y := mul(calldataload(add(encoded.offset, 0x20)), t)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8ee1bd0ebf6bb2bf74a9b38798d0f5cd3264c272b7e9c10b82ccbb4b6f5c1035\",\"license\":\"MIT\"},\"solady/src/utils/WebAuthn.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Base64} from \\\"./Base64.sol\\\";\\nimport {P256} from \\\"./P256.sol\\\";\\n\\n/// @notice WebAuthn helper.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/WebAuthn.sol)\\n/// @author Modified from Daimo WebAuthn (https://github.com/daimo-eth/p256-verifier/blob/master/src/WebAuthn.sol)\\n/// @author Modified from Coinbase WebAuthn (https://github.com/base-org/webauthn-sol/blob/main/src/WebAuthn.sol)\\nlibrary WebAuthn {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Helps make encoding and decoding easier, alleviates stack-too-deep.\\n    struct WebAuthnAuth {\\n        // The WebAuthn authenticator data.\\n        // See: https://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-authenticatordata.\\n        bytes authenticatorData;\\n        // The WebAuthn client data JSON.\\n        // See: https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson.\\n        string clientDataJSON;\\n        // Start index of \\\"challenge\\\":\\\"...\\\" in `clientDataJSON`.\\n        uint256 challengeIndex;\\n        // Start index of \\\"type\\\":\\\"...\\\" in `clientDataJSON`.\\n        uint256 typeIndex;\\n        // The r value of secp256r1 signature.\\n        bytes32 r;\\n        // The s value of secp256r1 signature.\\n        bytes32 s;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*              WEBAUTHN VERIFICATION OPERATIONS              */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Verifies a Webauthn Authentication Assertion.\\n    /// See: https://www.w3.org/TR/webauthn-2/#sctn-verifying-assertion.\\n    ///\\n    /// We do not verify all the steps as described in the specification, only ones\\n    /// relevant to our context. Please carefully read through this list before usage.\\n    ///\\n    /// Specifically, we do verify the following:\\n    /// - Verify that `authenticatorData` (which comes from the authenticator,\\n    ///   such as iCloud Keychain) indicates a well-formed assertion with the\\n    ///   \\\"User Present\\\" bit set. If `requireUserVerification` is set, checks that the\\n    ///   authenticator enforced user verification. User verification should be required\\n    ///   if, and only if, `options.userVerification` is set to required in the request.\\n    /// - Verifies that the client JSON is of type \\\"webauthn.get\\\",\\n    ///   i.e. the client was responding to a request to assert authentication.\\n    /// - Verifies that the client JSON contains the requested challenge.\\n    /// - Verifies that (r, s) constitute a valid signature over both the\\n    ///   `authData` and client JSON, for public key (x, y).\\n    ///\\n    /// We make some assumptions about the particular use case of this verifier,\\n    /// so we do NOT verify the following:\\n    /// - Does NOT verify that the origin in the `clientDataJSON` matches the\\n    ///   Relying Party's origin: it is considered the authenticator's responsibility to\\n    ///   ensure that the user is interacting with the correct RP. This is enforced by\\n    ///   most high quality authenticators properly, particularly the iCloud Keychain\\n    ///   and Google Password Manager were tested.\\n    /// - Does NOT verify That `topOrigin` in `clientDataJSON` is well-formed:\\n    ///   We assume it would never be present, i.e. the credentials are never used in a\\n    ///   cross-origin/iframe context. The website/app set up should disallow cross-origin\\n    ///   usage of the credentials. This is the default behavior for created credentials\\n    ///   in common settings.\\n    /// - Does NOT verify that the `rpIdHash` in `authenticatorData` is the SHA-256 hash\\n    ///   of the RP ID expected by the Relying Party:\\n    ///   this means that we rely on the authenticator to properly enforce\\n    ///   credentials to be used only by the correct RP.\\n    ///   This is generally enforced with features like Apple App Site Association\\n    ///   and Google Asset Links. To protect from edge cases in which a previously-linked\\n    ///   RP ID is removed from the authorized RP IDs, we recommend that messages\\n    ///   signed by the authenticator include some expiry mechanism.\\n    /// - Does NOT verify the credential backup state: this assumes the credential backup\\n    ///   state is NOT used as part of Relying Party business logic or policy.\\n    /// - Does NOT verify the values of the client extension outputs:\\n    ///   this assumes that the Relying Party does not use client extension outputs.\\n    /// - Does NOT verify the signature counter: signature counters are intended to enable\\n    ///   risk scoring for the Relying Party. This assumes risk scoring is not used as part\\n    ///   of Relying Party business logic or policy.\\n    /// - Does NOT verify the attestation object: this assumes that\\n    ///   response.attestationObject is NOT present in the response,\\n    ///   i.e. the RP does not intend to verify an attestation.\\n    function verify(\\n        bytes memory challenge,\\n        bool requireUserVerification,\\n        WebAuthnAuth memory auth,\\n        bytes32 x,\\n        bytes32 y\\n    ) internal view returns (bool result) {\\n        bytes32 messageHash;\\n        string memory encoded = Base64.encode(challenge, true, true);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let clientDataJSON := mload(add(auth, 0x20))\\n            let n := mload(clientDataJSON) // `clientDataJSON`'s length.\\n            let o := add(clientDataJSON, 0x20) // Start of `clientData`'s bytes.\\n            {\\n                let c := mload(add(auth, 0x40)) // Challenge index in `clientDataJSON`.\\n                let t := mload(add(auth, 0x60)) // Type index in `clientDataJSON`.\\n                let l := mload(encoded) // Cache `encoded`'s length.\\n                let q := add(l, 0x0d) // Length of `encoded` prefixed with '\\\"challenge\\\":\\\"'.\\n                mstore(encoded, shr(152, '\\\"challenge\\\":\\\"')) // Temp prefix with '\\\"challenge\\\":\\\"'.\\n                result :=\\n                    and(\\n                        // 11. Verify JSON's type. Also checks for possible addition overflows.\\n                        and(\\n                            eq(shr(88, mload(add(o, t))), shr(88, '\\\"type\\\":\\\"webauthn.get\\\"')),\\n                            lt(shr(128, or(t, c)), lt(add(0x14, t), n))\\n                        ),\\n                        // 12. Verify JSON's challenge. Includes a check for the closing '\\\"'.\\n                        and(\\n                            eq(keccak256(add(o, c), q), keccak256(add(encoded, 0x13), q)),\\n                            and(eq(byte(0, mload(add(add(o, c), q))), 34), lt(add(q, c), n))\\n                        )\\n                    )\\n                mstore(encoded, l) // Restore `encoded`'s length, in case of string interning.\\n            }\\n            // Skip 13., 14., 15.\\n            let l := mload(mload(auth)) // Length of `authenticatorData`.\\n            // 16. Verify that the \\\"User Present\\\" flag is set (bit 0).\\n            // 17. Verify that the \\\"User Verified\\\" flag is set (bit 2), if required.\\n            // See: https://www.w3.org/TR/webauthn-2/#flags.\\n            let u := or(1, shl(2, iszero(iszero(requireUserVerification))))\\n            result := and(and(result, gt(l, 0x20)), eq(and(mload(add(mload(auth), 0x21)), u), u))\\n            if result {\\n                let p := add(mload(auth), 0x20) // Start of `authenticatorData`'s bytes.\\n                let e := add(p, l) // Location of the word after `authenticatorData`.\\n                let w := mload(e) // Cache the word after `authenticatorData`.\\n                // 19. Compute `sha256(clientDataJSON)`.\\n                // 20. Compute `sha256(authenticatorData \\u2016 sha256(clientDataJSON))`.\\n                // forgefmt: disable-next-item\\n                messageHash := mload(staticcall(gas(),\\n                    shl(1, staticcall(gas(), 2, o, n, e, 0x20)), p, add(l, 0x20), 0x01, 0x20))\\n                mstore(e, w) // Restore the word after `authenticatorData`, in case of reuse.\\n                // `returndatasize()` is `0x20` on `sha256` success, and `0x00` otherwise.\\n                if iszero(returndatasize()) { invalid() }\\n            }\\n        }\\n        // `P256.verifySignature` returns false if `s > N/2` due to the malleability check.\\n        if (result) result = P256.verifySignature(messageHash, auth.r, auth.s, x, y);\\n    }\\n\\n    /// @dev Plain variant of verify.\\n    function verify(\\n        bytes memory challenge,\\n        bool requireUserVerification,\\n        bytes memory authenticatorData,\\n        string memory clientDataJSON,\\n        uint256 challengeIndex,\\n        uint256 typeIndex,\\n        bytes32 r,\\n        bytes32 s,\\n        bytes32 x,\\n        bytes32 y\\n    ) internal view returns (bool) {\\n        return verify(\\n            challenge,\\n            requireUserVerification,\\n            WebAuthnAuth(authenticatorData, clientDataJSON, challengeIndex, typeIndex, r, s),\\n            x,\\n            y\\n        );\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                ENCODING / DECODING HELPERS                 */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns `abi.encode(auth)`.\\n    function encodeAuth(WebAuthnAuth memory auth) internal pure returns (bytes memory) {\\n        return abi.encode(auth);\\n    }\\n\\n    /// @dev Performs a best-effort attempt to `abi.decode(auth)`. Won't revert.\\n    /// If any fields cannot be successfully extracted, `decoded` will not be populated,\\n    /// which will cause `verify` to return false (as `clientDataJSON` is empty).\\n    function tryDecodeAuth(bytes memory encodedAuth)\\n        internal\\n        pure\\n        returns (WebAuthnAuth memory decoded)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let n := mload(encodedAuth) } iszero(lt(n, 0xc0)) {} {\\n                let o := add(encodedAuth, 0x20) // Start of `encodedAuth`'s bytes.\\n                let e := add(o, n) // End of `encodedAuth` in memory.\\n                let p := add(mload(o), o) // Start of `encodedAuth`.\\n                if or(gt(add(p, 0xc0), e), lt(p, o)) { break }\\n                let authenticatorData := add(mload(p), p)\\n                let clientDataJSON := add(mload(add(p, 0x20)), p)\\n                if or(\\n                    or(gt(authenticatorData, e), lt(authenticatorData, p)),\\n                    or(gt(clientDataJSON, e), lt(clientDataJSON, p))\\n                ) { break }\\n                if or(\\n                    gt(add(add(authenticatorData, 0x20), mload(authenticatorData)), e),\\n                    gt(add(add(clientDataJSON, 0x20), mload(clientDataJSON)), e)\\n                ) { break }\\n                mstore(decoded, authenticatorData) // `authenticatorData`.\\n                mstore(add(decoded, 0x20), clientDataJSON) // `clientDataJSON`.\\n                mstore(add(decoded, 0x40), mload(add(p, 0x40))) // `challengeIndex`.\\n                mstore(add(decoded, 0x60), mload(add(p, 0x60))) // `typeIndex`.\\n                mstore(add(decoded, 0x80), mload(add(p, 0x80))) // `r`.\\n                mstore(add(decoded, 0xa0), mload(add(p, 0xa0))) // `s`.\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the compact encoding of `auth`:\\n    /// ```\\n    ///     abi.encodePacked(\\n    ///         uint16(auth.authenticatorData.length),\\n    ///         bytes(auth.authenticatorData),\\n    ///         bytes(auth.clientDataJSON),\\n    ///         uint16(auth.challengeIndex),\\n    ///         uint16(auth.typeIndex),\\n    ///         bytes32(auth.r),\\n    ///         bytes32(auth.s)\\n    ///     )\\n    /// ```\\n    /// Returns the empty string if any length or index exceeds 16 bits.\\n    function tryEncodeAuthCompact(WebAuthnAuth memory auth)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function copyBytes(o_, s_, c_) -> _e {\\n                mstore(o_, shl(240, mload(s_)))\\n                o_ := add(o_, c_)\\n                _e := add(o_, mload(s_)) // The end of the bytes.\\n                for { let d_ := sub(add(0x20, s_), o_) } 1 {} {\\n                    mstore(o_, mload(add(d_, o_)))\\n                    o_ := add(o_, 0x20)\\n                    if iszero(lt(o_, _e)) { break }\\n                }\\n            }\\n            let clientDataJSON := mload(add(0x20, auth))\\n            let c := mload(add(0x40, auth)) // `challengeIndex`.\\n            let t := mload(add(0x60, auth)) // `typeIndex`.\\n            // If none of the lengths are more than `0xffff`.\\n            if iszero(shr(16, or(or(t, c), or(mload(mload(auth)), mload(clientDataJSON))))) {\\n                result := mload(0x40)\\n                // `authenticatorData`, `clientDataJSON`.\\n                let o := copyBytes(copyBytes(add(result, 0x20), mload(auth), 2), clientDataJSON, 0)\\n                mstore(o, or(shl(240, c), shl(224, t))) // `challengeIndex`, `typeIndex`.\\n                mstore(add(o, 0x04), mload(add(0x80, auth))) // `r`.\\n                mstore(add(o, 0x24), mload(add(0xa0, auth))) // `s`.\\n                mstore(result, sub(add(o, 0x24), result)) // Store the length.\\n                mstore(add(o, 0x44), 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(o, 0x64)) // Allocate memory .\\n            }\\n        }\\n    }\\n\\n    /// @dev Approximately the same gas as `tryDecodeAuth`, but helps save on calldata.\\n    /// If any fields cannot be successfully extracted, `decoded` will not be populated,\\n    /// which will cause `verify` to return false (as `clientDataJSON` is empty).\\n    function tryDecodeAuthCompact(bytes memory encodedAuth)\\n        internal\\n        pure\\n        returns (WebAuthnAuth memory decoded)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function extractBytes(o_, l_) -> _m {\\n                _m := mload(0x40) // Grab the free memory pointer.\\n                let s_ := add(_m, 0x20)\\n                for { let i_ := 0 } 1 {} {\\n                    mstore(add(s_, i_), mload(add(o_, i_)))\\n                    i_ := add(i_, 0x20)\\n                    if iszero(lt(i_, l_)) { break }\\n                }\\n                mstore(_m, l_) // Store the length.\\n                mstore(add(l_, s_), 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(0x20, add(l_, s_))) // Allocate memory.\\n            }\\n            let n := mload(encodedAuth)\\n            if iszero(lt(n, 0x46)) {\\n                let o := add(encodedAuth, 0x20) // Start of `encodedAuth`'s bytes.\\n                let e := add(o, n) // End of `encodedAuth` in memory.\\n                n := shr(240, mload(o)) // Length of `authenticatorData`.\\n                let a := add(o, 0x02) // Start of `authenticatorData`.\\n                let c := add(a, n) // Start of `clientDataJSON`.\\n                let j := sub(e, 0x44) // Start of `challengeIndex`.\\n                if iszero(gt(c, j)) {\\n                    mstore(decoded, extractBytes(a, n)) // `authenticatorData`.\\n                    mstore(add(decoded, 0x20), extractBytes(c, sub(j, c))) // `clientDataJSON`.\\n                    mstore(add(decoded, 0x40), shr(240, mload(j))) // `challengeIndex`.\\n                    mstore(add(decoded, 0x60), shr(240, mload(add(j, 0x02)))) // `typeIndex`.\\n                    mstore(add(decoded, 0x80), mload(add(j, 0x04))) // `r`.\\n                    mstore(add(decoded, 0xa0), mload(add(j, 0x24))) // `s`.\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Calldata variant of `tryDecodeAuthCompact`.\\n    function tryDecodeAuthCompactCalldata(bytes calldata encodedAuth)\\n        internal\\n        pure\\n        returns (WebAuthnAuth memory decoded)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function extractBytes(o_, l_) -> _m {\\n                _m := mload(0x40) // Grab the free memory pointer.\\n                let s_ := add(_m, 0x20)\\n                calldatacopy(s_, o_, l_)\\n                mstore(_m, l_) // Store the length.\\n                mstore(add(l_, s_), 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(0x20, add(l_, s_))) // Allocate memory.\\n            }\\n            if iszero(lt(encodedAuth.length, 0x46)) {\\n                let e := add(encodedAuth.offset, encodedAuth.length) // End of `encodedAuth`.\\n                let n := shr(240, calldataload(encodedAuth.offset)) // Length of `authenticatorData`.\\n                let a := add(encodedAuth.offset, 0x02) // Start of `authenticatorData`.\\n                let c := add(a, n) // Start of `clientDataJSON`.\\n                let j := sub(e, 0x44) // Start of `challengeIndex`.\\n                if iszero(gt(c, j)) {\\n                    mstore(decoded, extractBytes(a, n)) // `authenticatorData`.\\n                    mstore(add(decoded, 0x20), extractBytes(c, sub(j, c))) // `clientDataJSON`.\\n                    mstore(add(decoded, 0x40), shr(240, calldataload(j))) // `challengeIndex`.\\n                    mstore(add(decoded, 0x60), shr(240, calldataload(add(j, 0x02)))) // `typeIndex`.\\n                    mstore(add(decoded, 0x80), calldataload(add(j, 0x04))) // `r`.\\n                    mstore(add(decoded, 0xa0), calldataload(add(j, 0x24))) // `s`.\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3ec910c14349103b54e013465ede6bd4ad51e501facb5e06da8dd37fe888f9bc\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b50604051612b90380380612b9083398101604081905261002f91610088565b8060405161003c9061007b565b6001600160a01b039091168152602001604051809103906000f080158015610068573d6000803e3d6000fd5b506001600160a01b0316608052506100b8565b61219080610a0083390190565b60006020828403121561009a57600080fd5b81516001600160a01b03811681146100b157600080fd5b9392505050565b6080516109216100df60003960008181604b0152818160eb015261023f01526109216000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806311464fbe1461004657806320d4d3dd1461009657806368e91b66146100a9575b600080fd5b61006d7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b61006d6100a4366004610366565b6100bc565b61006d6100b7366004610366565b610203565b60006101f98260001b604051806020016100d590610359565b6020820181038252601f19601f820116604052507f0000000000000000000000000000000000000000000000000000000000000000878760405160240161011d9291906103c6565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152918152602080830180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fc151c0b90000000000000000000000000000000000000000000000000000000017905290516101a293929101610437565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290526101de92916020016104a5565b60405160208183030381529060405280519060200120610327565b90505b9392505050565b6000806102118585856100bc565b905073ffffffffffffffffffffffffffffffffffffffff81163b8015610239575090506101fc565b8360001b7f000000000000000000000000000000000000000000000000000000000000000087876040516024016102719291906103c6565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fc151c0b900000000000000000000000000000000000000000000000000000000179052516102f190610359565b6102fc929190610437565b8190604051809103906000f590508015801561031c573d6000803e3d6000fd5b509695505050505050565b60006101fc8383306000604051836040820152846020820152828152600b8101905060ff815360559020949350505050565b610417806104d583390190565b600080600083850360a081121561037c57600080fd5b606081121561038a57600080fd5b50839250606084013573ffffffffffffffffffffffffffffffffffffffff811681146103b557600080fd5b929592945050506080919091013590565b8235815260208084013590820152608081016040840135600381106103ea57600080fd5b604083015273ffffffffffffffffffffffffffffffffffffffff92909216606090910152919050565b60005b8381101561042e578181015183820152602001610416565b50506000910152565b73ffffffffffffffffffffffffffffffffffffffff831681526040602082015260008251806040840152610472816060850160208701610413565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016060019392505050565b600083516104b7818460208801610413565b8351908301906104cb818360208801610413565b0194935050505056fe608060405260405161041738038061041783398101604081905261002291610268565b61002c8282610033565b5050610352565b61003c82610092565b6040516001600160a01b038316907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a280511561008657610081828261010e565b505050565b61008e610185565b5050565b806001600160a01b03163b6000036100cd57604051634c9c8ce360e01b81526001600160a01b03821660048201526024015b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b0319166001600160a01b0392909216919091179055565b6060600080846001600160a01b03168460405161012b9190610336565b600060405180830381855af49150503d8060008114610166576040519150601f19603f3d011682016040523d82523d6000602084013e61016b565b606091505b50909250905061017c8583836101a6565b95945050505050565b34156101a45760405163b398979f60e01b815260040160405180910390fd5b565b6060826101bb576101b682610205565b6101fe565b81511580156101d257506001600160a01b0384163b155b156101fb57604051639996b31560e01b81526001600160a01b03851660048201526024016100c4565b50805b9392505050565b8051156102155780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b634e487b7160e01b600052604160045260246000fd5b60005b8381101561025f578181015183820152602001610247565b50506000910152565b6000806040838503121561027b57600080fd5b82516001600160a01b038116811461029257600080fd5b60208401519092506001600160401b03808211156102af57600080fd5b818501915085601f8301126102c357600080fd5b8151818111156102d5576102d561022e565b604051601f8201601f19908116603f011681019083821181831017156102fd576102fd61022e565b8160405282815288602084870101111561031657600080fd5b610327836020830160208801610244565b80955050505050509250929050565b60008251610348818460208701610244565b9190910192915050565b60b7806103606000396000f3fe6080604052600a600c565b005b60186014601a565b605e565b565b600060597f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5473ffffffffffffffffffffffffffffffffffffffff1690565b905090565b3660008037600080366000845af43d6000803e808015607c573d6000f35b3d6000fdfea2646970667358221220d7f23a80daebb5531c9e4a18d87e812fca112e5df7e56433218edcc12bbe415d64736f6c63430008170033a26469706673582212204aec8096382781e3dcd4e171f2ed40f3ffa23291e8c18f6557c318f750f2389564736f6c6343000817003360a06040523480156200001157600080fd5b5060405162002190380380620021908339810160408190526200003491620000ba565b6001600160a01b0381166080526200004b62000052565b50620000ec565b63409feecd1980546001811615620000725763f92ee8a96000526004601cfd5b6001600160401b03808260011c14620000b5578060011b8355806020527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2602080a15b505050565b600060208284031215620000cd57600080fd5b81516001600160a01b0381168114620000e557600080fd5b9392505050565b6080516120736200011d60003960008181610339015281816107ee0152818161098e0152610e4601526120736000f3fe60806040526004361061012d5760003560e01c8063b0d691fe116100a5578063c151c0b911610074578063d605e6bf11610059578063d605e6bf14610407578063f23a6e6114610427578063fdbaa17d1461046d57600080fd5b8063c151c0b9146103d2578063d087d288146103f257600080fd5b8063b0d691fe1461032a578063b3ca336f146102d3578063b61d27f61461035d578063bc197c811461038a57600080fd5b806334fcd5be116100fc57806355540e21116100e157806355540e21146102b35780636e2cbb69146102d35780637a5ee0ca146102fd57600080fd5b806334fcd5be146102645780635437988d1461029157600080fd5b806301ffc9a714610139578063150b7a021461016e57806319822f7c146101e45780632b7ac3f31461021257600080fd5b3661013457005b600080fd5b34801561014557600080fd5b5061015961015436600461173a565b61048d565b60405190151581526020015b60405180910390f35b34801561017a57600080fd5b506101b36101893660046117ee565b7f150b7a020000000000000000000000000000000000000000000000000000000095945050505050565b6040517fffffffff000000000000000000000000000000000000000000000000000000009091168152602001610165565b3480156101f057600080fd5b506102046101ff36600461185d565b610572565b604051908152602001610165565b34801561021e57600080fd5b5060005461023f9073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610165565b34801561027057600080fd5b5061028461027f3660046118f6565b610598565b60405161016591906119a6565b34801561029d57600080fd5b506102b16102ac366004611a28565b61061f565b005b3480156102bf57600080fd5b506102b16102ce366004611a52565b610633565b3480156102df57600080fd5b506102046102ee366004611a85565b60009182526020526040902090565b34801561030957600080fd5b5061031d610318366004611aa7565b61068e565b6040516101659190611aef565b34801561033657600080fd5b507f000000000000000000000000000000000000000000000000000000000000000061023f565b34801561036957600080fd5b5061037d610378366004611b4b565b610713565b6040516101659190611ba5565b34801561039657600080fd5b506101b36103a5366004611bb8565b7fbc197c810000000000000000000000000000000000000000000000000000000098975050505050505050565b3480156103de57600080fd5b506102b16103ed366004611c73565b610754565b3480156103fe57600080fd5b506102046107ea565b34801561041357600080fd5b506102b1610422366004611aa7565b6108a9565b34801561043357600080fd5b506101b3610442366004611ca5565b7ff23a6e61000000000000000000000000000000000000000000000000000000009695505050505050565b34801561047957600080fd5b506102b1610488366004611d1d565b610930565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f150b7a0200000000000000000000000000000000000000000000000000000000148061052057507fffffffff0000000000000000000000000000000000000000000000000000000082167f4e2312e000000000000000000000000000000000000000000000000000000000145b8061056c57507fffffffff0000000000000000000000000000000000000000000000000000000082167f01ffc9a700000000000000000000000000000000000000000000000000000000145b92915050565b600061057c610976565b6105868484610a1c565b905061059182610c0a565b9392505050565b60606105a2610976565b6040519050818152806020018260051b81018360051b858337805b8083146106145782518601604081013581018035602082018537600038823586602086013586355af16105f3573d6000853e3d84fd5b50508183523d8252602082013d6000823e602093909301923d0191506105bd565b506040525092915050565b610627610c81565b61063081610cea565b50565b61063b610c81565b6040805160608101825273ffffffffffffffffffffffffffffffffffffffff8416815260006020820181905291810183600281111561067c5761067c611ac0565b9052905061068981610d5d565b505050565b6106af60408051606081018252600080825260208201819052909182015290565b6000828152600160208181526040928390208351606081018552815481529281015491830191909152600280820154929391929184019160ff16908111156106f9576106f9611ac0565b600281111561070a5761070a611ac0565b90525092915050565b606061071d610976565b5060405181838237600038838387895af161073b573d6000823e3d81fd5b3d8152602081013d6000823e3d01604052949350505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffbf60113280546003825580156107a65760018160011c14303b1061079d5763f92ee8a96000526004601cfd5b818160ff1b1b91505b506107b18383610e0c565b8015610689576002815560016020527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2602080a1505050565b60007f00000000000000000000000000000000000000000000000000000000000000006040517f35567e1a0000000000000000000000000000000000000000000000000000000081523060048201526000602482015273ffffffffffffffffffffffffffffffffffffffff91909116906335567e1a90604401602060405180830381865afa158015610880573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108a49190611d52565b905090565b6108b1610c81565b60008181526001602081905260408083208381559182019290925560020180547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169055517f1b434e265f6e21f60a4fb02d9ffe4bdd1f98cf1c304a8535ed5f04271f155657906109259083815260200190565b60405180910390a150565b610938610c81565b6000604051806060016040528085815260200184815260200183600281111561096357610963611ac0565b9052905061097081610d5d565b50505050565b3373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614610a1a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f6163636f756e743a206e6f742066726f6d20456e747279506f696e740000000060448201526064015b60405180910390fd5b565b600080610a2d610100850185611d6b565b610a3c91602091600091611dd0565b610a4591611dfa565b905060006001600083815260200190815260200160002060405180606001604052908160008201548152602001600182015481526020016002820160009054906101000a900460ff166002811115610a9f57610a9f611ac0565b6002811115610ab057610ab0611ac0565b9052509050600081604001516002811115610acd57610acd611ac0565b03610b34576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f6163636f756e743a20756e617574686f72697a656400000000000000000000006044820152606401610a11565b366000610b45610100880188611d6b565b610b53916020908290611dd0565b6020850151919350915015610bb657600283604001516002811115610b7a57610b7a611ac0565b03610b9657610b8b83878484610e91565b94505050505061056c565b610b8b8387610baf898860009182526020526040902090565b8585610f43565b600283604001516002811115610bce57610bce611ac0565b03610bdf57610b8b838784846110e4565b610bff8387610bf8898860009182526020526040902090565b8585611188565b979650505050505050565b80156106305760405160009033907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90849084818181858888f193505050503d8060008114610c75576040519150601f19603f3d011682016040523d82523d6000602084013e610c7a565b606091505b5050505050565b333014610a1a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f6f6e6c792073656c6600000000000000000000000000000000000000000000006044820152606401610a11565b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527fba4d89f2b152b9d8b347adcb7ba054b21f39d83806bc75af8b2865cb8fc899d490602001610925565b805160208083018051600093845282526040808420808552600193849052938190208551815591518284015584015160028083018054879591927fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0090911691908490811115610dce57610dce611ac0565b0217905550506040518281527f5c1be025a34354869dc1e444a870ac3fba82d3908fc65191bb85af33aba04f51915060200160405180910390a15050565b610e23610e1e36849003840184611e65565b610d5d565b610e2c81610cea565b60405173ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016907fcf8ddf065b2cfdd1f0d020f72f2e835a9171d3393e3af43f3677fbd7baa0908290600090a25050565b60008084604051602001610ea791815260200190565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181526020601f87018190048102840181019092528583529250600091610f1391849190889088908190840183828082843760009201919091525061127192505050565b9050610f2b826001838a600001518b6020015161132b565b610f36576001610bff565b6000979650505050505050565b60008085604051602001610f5991815260200190565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815291905290506000610fd682610f9c866041818a611dd0565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061127192505050565b9050600061105461100c886020527b19457468657265756d205369676e6564204d6573736167653a0a3332600052603c60042090565b61101a60416000898b611dd0565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061146292505050565b73ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614905060006110bc846001858d600001518e6020015161132b565b90508180156110c85750805b6110d35760016110d6565b60005b9a9950505050505050505050565b6000611154611118856020527b19457468657265756d205369676e6564204d6573736167653a0a3332600052603c60042090565b84848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061146292505050565b855173ffffffffffffffffffffffffffffffffffffffff90811691161461117c57600161117f565b60005b95945050505050565b6000806111cb6111bd866020527b19457468657265756d205369676e6564204d6573736167653a0a3332600052603c60042090565b61101a604160008789611dd0565b6000805473ffffffffffffffffffffffffffffffffffffffff908116921691909114915061122e611221886020527b19457468657265756d205369676e6564204d6573736167653a0a3332600052603c60042090565b61101a866041818a611dd0565b885173ffffffffffffffffffffffffffffffffffffffff90811691161490508180156112575750805b611262576001611265565b60005b98975050505050505050565b6040805160c081018252606080825260208201819052600092820183905281018290526080810182905260a08101919091526000806000806000806000888060200190518101906112c29190611f77565b96509650965096509650965096506040518060c00160405280888152602001611301876112fb6112f48f60018061150d565b8b9061161e565b9061161e565b81526020018581526020018481526020018381526020018281525097505050505050505092915050565b600080600061133c8860018061150d565b905060208601518051602082019150604088015160608901518451600d81017f226368616c6c656e6765223a220000000000000000000000000000000000000060981c87528484820110602282868901015160001a14168160138901208286890120141685846014011085851760801c107f2274797065223a22776562617574686e2e67657422000000000000000000000060581c8589015160581c14161698505080865250505087515189151560021b600117808160218c510151161460208311881616965050851561143957602089510181810180516020600160208601856020868a8c60025afa60011b5afa51915295503d905061143957fe5b5050508215611457576112658287608001518860a00151888861162a565b505095945050505050565b600060405182516040811461147f57604181146114b957506114f8565b604084015160ff81901c601b016020527f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff166060526114cd565b606084015160001a60205260408401516060525b50836000526020830151604052602060016080600060015afa5191506000606052806040523d611506575b638baa579f6000526004601cfd5b5092915050565b606083518015611616576003600282010460021b60405192507f4142434445464748494a4b4c4d4e4f505152535455565758595a616263646566601f526106708515027f6768696a6b6c6d6e6f707172737475767778797a303132333435363738392d5f18603f52602083018181018388602001018051600082525b60038a0199508951603f8160121c1651600053603f81600c1c1651600153603f8160061c1651600253603f8116516003535060005184526004840193508284106115895790526020016040527f3d3d000000000000000000000000000000000000000000000000000000000000600384066002048083039190915260008615159091029182900352900382525b509392505050565b606061059183836116c0565b6000604051868152856020820152846040820152836060820152826080820152600080526020600060a0836101005afa503d61168a5760203d60a0836dd01ea45f9efd5c54f037fa57ea1a5afa503d61168a5763d0d5039b3d526004601cfd5b506000516001147f7fffffff800000007fffffffffffffffde737d56d38bcf4279dce5617e3192a8851110905095945050505050565b60405182517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0906020810182165b85810151848201528201806116ee575083518184018360208301165b868101518282015284018061170a5750506000910183810160208101929092528352604090810190525092915050565b60006020828403121561174c57600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461059157600080fd5b803573ffffffffffffffffffffffffffffffffffffffff811681146117a057600080fd5b919050565b60008083601f8401126117b757600080fd5b50813567ffffffffffffffff8111156117cf57600080fd5b6020830191508360208285010111156117e757600080fd5b9250929050565b60008060008060006080868803121561180657600080fd5b61180f8661177c565b945061181d6020870161177c565b935060408601359250606086013567ffffffffffffffff81111561184057600080fd5b61184c888289016117a5565b969995985093965092949392505050565b60008060006060848603121561187257600080fd5b833567ffffffffffffffff81111561188957600080fd5b8401610120818703121561189c57600080fd5b95602085013595506040909401359392505050565b60008083601f8401126118c357600080fd5b50813567ffffffffffffffff8111156118db57600080fd5b6020830191508360208260051b85010111156117e757600080fd5b6000806020838503121561190957600080fd5b823567ffffffffffffffff81111561192057600080fd5b61192c858286016118b1565b90969095509350505050565b60005b8381101561195357818101518382015260200161193b565b50506000910152565b60008151808452611974816020860160208601611938565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b600060208083016020845280855180835260408601915060408160051b87010192506020870160005b82811015611a1b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0888603018452611a0985835161195c565b945092850192908501906001016119cf565b5092979650505050505050565b600060208284031215611a3a57600080fd5b6105918261177c565b8035600381106117a057600080fd5b60008060408385031215611a6557600080fd5b611a6e8361177c565b9150611a7c60208401611a43565b90509250929050565b60008060408385031215611a9857600080fd5b50508035926020909101359150565b600060208284031215611ab957600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b81518152602080830151908201526040820151606082019060038110611b3e577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b8060408401525092915050565b60008060008060608587031215611b6157600080fd5b611b6a8561177c565b935060208501359250604085013567ffffffffffffffff811115611b8d57600080fd5b611b99878288016117a5565b95989497509550505050565b602081526000610591602083018461195c565b60008060008060008060008060a0898b031215611bd457600080fd5b611bdd8961177c565b9750611beb60208a0161177c565b9650604089013567ffffffffffffffff80821115611c0857600080fd5b611c148c838d016118b1565b909850965060608b0135915080821115611c2d57600080fd5b611c398c838d016118b1565b909650945060808b0135915080821115611c5257600080fd5b50611c5f8b828c016117a5565b999c989b5096995094979396929594505050565b6000808284036080811215611c8757600080fd5b6060811215611c9557600080fd5b50829150611a7c6060840161177c565b60008060008060008060a08789031215611cbe57600080fd5b611cc78761177c565b9550611cd56020880161177c565b94506040870135935060608701359250608087013567ffffffffffffffff811115611cff57600080fd5b611d0b89828a016117a5565b979a9699509497509295939492505050565b600080600060608486031215611d3257600080fd5b8335925060208401359150611d4960408501611a43565b90509250925092565b600060208284031215611d6457600080fd5b5051919050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112611da057600080fd5b83018035915067ffffffffffffffff821115611dbb57600080fd5b6020019150368190038213156117e757600080fd5b60008085851115611de057600080fd5b83861115611ded57600080fd5b5050820193919092039150565b8035602083101561056c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602084900360031b1b1692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060608284031215611e7757600080fd5b6040516060810181811067ffffffffffffffff82111715611e9a57611e9a611e36565b80604052508235815260208301356020820152611eb960408401611a43565b60408201529392505050565b600067ffffffffffffffff80841115611ee057611ee0611e36565b604051601f85017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715611f2657611f26611e36565b81604052809350858152868686011115611f3f57600080fd5b611f4d866020830187611938565b5050509392505050565b600082601f830112611f6857600080fd5b61059183835160208501611ec5565b600080600080600080600060e0888a031215611f9257600080fd5b875167ffffffffffffffff80821115611faa57600080fd5b818a0191508a601f830112611fbe57600080fd5b611fcd8b835160208501611ec5565b985060208a0151915080821115611fe357600080fd5b611fef8b838c01611f57565b975060408a015191508082111561200557600080fd5b506120128a828b01611f57565b955050606088015193506080880151925060a0880151915060c088015190509295989194975092955056fea26469706673582212201f903fe3eef6d6f53371e8ea238cf0c52fbcfa864c0ce6c53b9de0a08cf7952064736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c806311464fbe1461004657806320d4d3dd1461009657806368e91b66146100a9575b600080fd5b61006d7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b61006d6100a4366004610366565b6100bc565b61006d6100b7366004610366565b610203565b60006101f98260001b604051806020016100d590610359565b6020820181038252601f19601f820116604052507f0000000000000000000000000000000000000000000000000000000000000000878760405160240161011d9291906103c6565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152918152602080830180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fc151c0b90000000000000000000000000000000000000000000000000000000017905290516101a293929101610437565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290526101de92916020016104a5565b60405160208183030381529060405280519060200120610327565b90505b9392505050565b6000806102118585856100bc565b905073ffffffffffffffffffffffffffffffffffffffff81163b8015610239575090506101fc565b8360001b7f000000000000000000000000000000000000000000000000000000000000000087876040516024016102719291906103c6565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fc151c0b900000000000000000000000000000000000000000000000000000000179052516102f190610359565b6102fc929190610437565b8190604051809103906000f590508015801561031c573d6000803e3d6000fd5b509695505050505050565b60006101fc8383306000604051836040820152846020820152828152600b8101905060ff815360559020949350505050565b610417806104d583390190565b600080600083850360a081121561037c57600080fd5b606081121561038a57600080fd5b50839250606084013573ffffffffffffffffffffffffffffffffffffffff811681146103b557600080fd5b929592945050506080919091013590565b8235815260208084013590820152608081016040840135600381106103ea57600080fd5b604083015273ffffffffffffffffffffffffffffffffffffffff92909216606090910152919050565b60005b8381101561042e578181015183820152602001610416565b50506000910152565b73ffffffffffffffffffffffffffffffffffffffff831681526040602082015260008251806040840152610472816060850160208701610413565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016060019392505050565b600083516104b7818460208801610413565b8351908301906104cb818360208801610413565b0194935050505056fe608060405260405161041738038061041783398101604081905261002291610268565b61002c8282610033565b5050610352565b61003c82610092565b6040516001600160a01b038316907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a280511561008657610081828261010e565b505050565b61008e610185565b5050565b806001600160a01b03163b6000036100cd57604051634c9c8ce360e01b81526001600160a01b03821660048201526024015b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b0319166001600160a01b0392909216919091179055565b6060600080846001600160a01b03168460405161012b9190610336565b600060405180830381855af49150503d8060008114610166576040519150601f19603f3d011682016040523d82523d6000602084013e61016b565b606091505b50909250905061017c8583836101a6565b95945050505050565b34156101a45760405163b398979f60e01b815260040160405180910390fd5b565b6060826101bb576101b682610205565b6101fe565b81511580156101d257506001600160a01b0384163b155b156101fb57604051639996b31560e01b81526001600160a01b03851660048201526024016100c4565b50805b9392505050565b8051156102155780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b634e487b7160e01b600052604160045260246000fd5b60005b8381101561025f578181015183820152602001610247565b50506000910152565b6000806040838503121561027b57600080fd5b82516001600160a01b038116811461029257600080fd5b60208401519092506001600160401b03808211156102af57600080fd5b818501915085601f8301126102c357600080fd5b8151818111156102d5576102d561022e565b604051601f8201601f19908116603f011681019083821181831017156102fd576102fd61022e565b8160405282815288602084870101111561031657600080fd5b610327836020830160208801610244565b80955050505050509250929050565b60008251610348818460208701610244565b9190910192915050565b60b7806103606000396000f3fe6080604052600a600c565b005b60186014601a565b605e565b565b600060597f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5473ffffffffffffffffffffffffffffffffffffffff1690565b905090565b3660008037600080366000845af43d6000803e808015607c573d6000f35b3d6000fdfea2646970667358221220d7f23a80daebb5531c9e4a18d87e812fca112e5df7e56433218edcc12bbe415d64736f6c63430008170033a26469706673582212204aec8096382781e3dcd4e171f2ed40f3ffa23291e8c18f6557c318f750f2389564736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "createAccount((bytes32,bytes32,uint8),address,uint256)": {
        "notice": "create an account, and return its address. returns the address even if the account is already deployed. Note that during UserOperation execution, this method is called only if the account is not deployed. This method returns an existing account address so that entryPoint.getSenderAddress() would work even after account creation"
      },
      "getAddress((bytes32,bytes32,uint8),address,uint256)": {
        "notice": "calculate the counterfactual address of this account as it would be returned by createAccount()"
      }
    },
    "notice": "The factory contract for SimpleTeamAccount. SimpleTeamAccountFactory is originally forked from SimpleAccountFactory.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}